[
  {
    "id": 1,
    "series_id": null,
    "category_id": 2,
    "parent_id": null,
    "name": "A streamlined approach to Laravel validation",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "a-streamlined-approach-to-laravel-validation",
    "excerpt": "It has been while (almost two years) since I wrote an article here and I've decided to make my triumphant return with an article I never managed to get around to writing.\r\n\r\nAs the title may suggest, this article is about streamlining validation with Laravel. While the final aim is to explain and present you with a quick and simple abstracted validator that requires minimal code in the actual implementation stage, before we get there I will need to cover the usual methods of validation which are default validation, form request validation and model validation. So let's start.",
    "content": "It has been while (almost two years) since I wrote an article here and I’ve decided to make my triumphant return with an article I never managed to get around to writing.\r\n\r\nAs the title may suggest, this article is about streamlining validation with Laravel. While the final aim is to explain and present you with a quick and simple abstracted validator that requires minimal code in the actual implementation stage, before we get there I will need to cover the usual methods of validation which are default validation, form request validation and model validation. So let’s start.\r\n\r\n### Default Validation\r\n\r\nWhen I say default validation I’m referring to Laravels base validator with no packages or abstraction around it. If you’re unfamiliar with this or need a recap, [check out the documentation here](https://laravel.com/docs/5.2/validation).\r\n\r\nLets take a look at the example used on the documentation.\r\n\r\n```php\r\n$this->validate($request, [\r\n    'title' => 'required|unique:posts|max:255',\r\n    'body'  => 'required',\r\n]);\r\n```\r\n\r\nAs you can see this is relying on the usage of the ValidatesRequests trait which is used in the default Laravel controller, but what exactly does this method do? Let’s take a look.\r\n\r\n```php\r\npublic function validate(Request $request, array $rules, array $messages = array()) {\r\n    $validator = $this->getValidationFactory()->make($request->all(), $rules, $messages);\r\n\r\n    if ($validator->fails()) {\r\n        $this->throwValidationException($request, $validator);\r\n    }\r\n}\r\n```\r\n\r\nThere are some serious levels of abstraction here but let’s break this down into something you’d be more familiar with from previous versions of Laravel.\r\n\r\n```php\r\n$validator = Validator::make($input, $results);\r\n\r\nif($validator->fails()) {\r\n    throw new \\Exception('Validation failed');\r\n}\r\n```\r\n\r\nThis approach is something that I have favoured since the days of Laravel 4.2. This approach actually covers the majority of the streamlining approach that I want to show you, simply by throwing an exception you’ve removed the need to manually check the status of the a validator every time you want to run one.\r\n\r\nThat being said, there are a couple of problems I have with this approach.\r\n\r\nFirstly, while it’s nice to throw in an entire object representing the request and have the validator validate all input, it’s not something that you want to find yourself getting into the habit of. For a while now I’ve seen a lot of people using the `$request->all()` method when collecting user input, and while I’m aware that Laravel by default has some superb security and that a validator isn’t really doing anything that could be exploited by some malicious input, being lazy and just throwing handfuls of user input at parts of your application is a bad habit that you shouldn’t let yourself get into.\r\n\r\nSecondly, this approach also requires that you define the rules for the validation in the controller, and while this isn’t really a security issue or a bad habit, you’ll find that later down the road when sifting through the controllers of a large application trying to find the definition of the validation rules you’ll wish that these were abstracted out.\r\n\r\nIn conclusion, Laravels default validation will suffice in a pinch, it’s good for getting started and rapid prototyping but it feels somewhat lazy and not very optimal, so lets move into the next one, form request validation.\r\n\r\n### Form Request Validaiton\r\n\r\nForm request validation is a relatively new feature that was brought to us in Laravel 5.0, and while some of the underlying core code may have changed, the actual implementation and usage of this feature has remained somewhat static. If you’re unfamiliar with this approach or need a recap, [check out the documentation here](https://laravel.com/docs/5.2/validation#form-request-validation).\r\n\r\nFor a brief explanation of what exactly this is, let’s quote the documentation.\r\n\r\n> or more complex validation scenarios, you may wish to create a “form request”. Form requests are custom request classes that contain validation logic.\r\n\r\nEssentially the idea behind this is that you have your own class that extends the Laravel `Request` class, except this class is capable of defining rules so that it may be automatically validated.\r\n\r\nWhile in theory this is a pretty cool approach, and while it does provide us with a level of abstraction so that we don’t have all of this validation code within our controllers, it does mean that we’re offloading the task of validating data to the HTTP layer, and don’t forget, that some of Laravels validation rules will actually communicate with the database, so now we have the HTTP layer communicating with the database before it even hits our controllers, which should realistically be the start of our logic. This is bad, bad bad bad!\r\n\r\nBy all means have a play with this feature, see what it’s like and get your own feel for it, but I highly recommend that you do not use this is an actual production application, clear definitions and responsibilities are important for maintaining your codebase and limiting the amount of work required to change and/or fix something in the future. If you have to use an out of the box solution, use Laravels default validation.\r\n\r\nNow we go from the start of the lifecycle to near the end, while somehow still being as bad.\r\n\r\n### Model Validation\r\n\r\nModel validation is something that’s not part of Laravels core, but instead something often provided by packages or implemented at a basic level by the developer working with the system.\r\n\r\nThe standard approach for model validation often has you create models that look like the following.\r\n\r\n```php\r\nclass MyModel extends Model {\r\n\r\n    protected $fillable = ['field1', 'field2'];\r\n\r\n    protected $rules = [\r\n        'create' => [\r\n            'field1' => ['required'],\r\n            'field2' => ['required']\r\n         ],\r\n    ];\r\n\r\n}\r\n```\r\n\r\nNice and simple right? The rules are defined in your model and would be called automatically by events hooking into `Model::creating()` or `Model::saving()`. This approach doesn’t actually take into consideration one of Eloquents wonderful features, mutators. For example, when creating a `User` model with Eloquent I will always create the following mutator.\r\n\r\n```php\r\npublic function setPasswordAttribute($value) {\r\n    $this->attributes['password'] = Hash::make($value);\r\n}\r\n```\r\n\r\nIf I were using this approach the validator would validate the hash of the password, rather than the actual password. The same goes for any other field that you may have a mutator for.\r\n\r\nYou may find yourself thinking\r\n\r\n>Hey, why can’t the validation on the model happen when a user calls fill()?\r\n\r\nThe answer is simple, because you shouldn’t be using the fill method, it’s lazy and when I see it used it’s either just having a whole mess of user input thrown into it (Usually from `$request->all()`) or it’s through so many levels of abstraction that I genuinely have no idea what it is actually saving to the model.\r\n\r\nAnother thing to consider is that like the structure of your response, user input can quite often be totally different to how the data is stored. Maybe the user is submitting one form, but this data actually creates two maybe three models, that’s two or three separate instances of validation there, rather than the one that should be. If you believe there should be that many, remember that the validation of data (user input) has very little to do with the storage of the data. This actually brings us quite nicely to my final point about this approach.\r\n\r\n**YOUR PERSISTENCE LAYER SHOULD NOT BE RESPONSIBLE FOR VALIDATING DATA**. Feel free to reread that a couple of times and let it settle in.\r\n\r\nGot that? Well have another few more reads of it to make sure that we’re on the same page.\r\n\r\nFor those of you that are curious as to what a “persistence layer” is, the persistence layer is where data is persisted, typically this will be in a database but we’re in a place now where databases are not that only way to store data. This layer is sometimes called the “data layer”, “datastore layer” or “database layer”. The naming isn’t important, what is important is what it does.\r\n\r\nThis layers job is basically to take data and persist it, whether that means throwing it an API, into a database, datastore, whatever, that is its sole job, retrieving and saving data. Validating data is a logic step, and can be considered business and/or application logic (I’m not getting into the argument of definition) so it belongs somewhere else.\r\n\r\nJust like the response layer or view layer has its own specific logic often referred to as “display logic” this layer has its own level of “data logic” which I think is a name that confuses a lot of people and leads to this. The logic that happens in this layer is specific to the storage of the data and/or the communication with the datastore. It doesn’t and shouldn’t care how valid or invalid the contents actually is.\r\n\r\nDo not play with, use or contemplate this approach. While it sounds nice on paper, and it may “make your life easier” you’ll regret it in the long run, and you’ll find yourself getting into bad habits. I don’t know why I dislike this approach more than form requests, but I do.\r\n\r\nFINALLY we’ve made it all the way through to the part you’ve all been waiting for, some of my wonderful code.\r\n\r\n### The streamlinked approach\r\n\r\nNow that we’ve covered Laravels default validation, form request validation and even the third party model validation let me show the fourth and final approach of the day. This approach combines the one good part of form requests with the streamline approach of default validation, but throws in some nice magic in a more optimal way that doesn’t involve encroaching into the territory of your other layers.\r\n\r\nFor our examples, lets create it for users. Now you’ve got your application setup, you have the following classes.\r\n\r\n- User (model/entity)\r\n- UserController\r\n- UserRepository\r\n\r\nIn the lifecycle of our example application here the data will go `UserController -> UserRepository -> User`. So where exactly do we perform the validation? Well, my approach sits in the UserController but realistically could even sit in the UserRepository if you so wish. It doesn’t add an extra step, but instead provides a fire and forget approach just like the default laravel validation.\r\n\r\nFor this approach, we’ll want to create ourselves a UserValidator.\r\n\r\n```php\r\nclass UserValidator extends BaseValidator {\r\n    public static $rules = [\r\n        'create'  => [...],\r\n        'update'   => [...],\r\n        'password' => [...]\r\n    ];\r\n}\r\n```\r\n\r\nAs you can see, the implementation of this approach so far, is really simple. You extend a base class and just define your rules as you see fit. To actually use this class in your controller you would have a method like the following.\r\n\r\n```php\r\npublic function store(Request $request, UserValidator $validator, UserRepository $repository) {\r\n    $input = $request->only(['username', 'password']);\r\n    $validator->validForCreate($input);\r\n\r\n    if($user = $repository->create($input)) {\r\n        Auth::login($user);\r\n        return redirect()->route('user.dashboard');\r\n    }\r\n\r\n    return redirect()->back()->with(['error' => 'Unable to create user']);\r\n}\r\n```\r\n\r\nYou may be able to figure out what’s going on here, but I’ll clarify for those of you that are still uncertain. Firstly I’m collecting the user input, and only the user input that I need before passing it along to a method within the validator, which will validate against matching rules and throw an exception if it fails. The final part of the `validFor` method corresponds directly to the defined list of rules within my validator.\r\n\r\nUsually as a final step of the validation I like to add an automated response for a validation exception inside the render method of the `Exceptions\\Handler` class provided by Laravel.\r\n\r\n```php\r\npublic function render($request, Exception $e)\r\n{\r\n    if($e instanceof ValidationException) {\r\n        return redirect()->back()->withErrors($e->errors());\r\n    }\r\n\r\n    return parent::render($request, $e);\r\n}\r\n```\r\n\r\nI’m aware that the above error handler only works for non api/ajax calls but that’s not our concern right now. The idea behind it is that I don’t have to fanny around creating validation logic for every part of the application, I just simply define my rules and the small amount of work that I did on this at the start guarantees that my validation is as automated as can be with users being taken back to the form with the validation errors, allowing me to focus on the actual functionality.\r\n\r\nThat’s it for the implementation of the method, but now comes the fun bit, the creation of the `BaseValidator` class.\r\n\r\n```php\r\nabstract class BaseValidator\r\n{\r\n\r\n    public static $rules    = ['create' => [], 'update' => []];\r\n    public static $messages = ['create' => [], 'update' => []];\r\n\r\n    /**\r\n     * @var \\Illuminate\\Validation\\Factory\r\n     */\r\n    protected $validator;\r\n\r\n    /**\r\n     * @param Factory $validator\r\n     */\r\n    public function __construct(Factory $validator)\r\n    {\r\n        $this->validator = $validator;\r\n    }\r\n\r\n    public function __call($method, $arguments)\r\n    {\r\n        if (starts_with($method, 'validFor')) {\r\n            $name = snake_case(substr($method, 8));\r\n            if (isset(static::$messages[$name])) {\r\n                $messages = static::$messages[$name];\r\n            } else {\r\n                $messages = [];\r\n            }\r\n\r\n            if (isset(static::$rules[$name])) {\r\n                $rules = static::$rules[$name];\r\n                if (isset($arguments[1]) && is_array($arguments[1])) {\r\n                    $rules = array_merge($rules, $arguments[1]);\r\n                }\r\n                return $this->fire($arguments[0], $rules, $messages);\r\n            }\r\n        }\r\n    }\r\n    /**\r\n     * Generic method\r\n     *\r\n     * @param String $action   The action that define the validation. It corresponds to the array key on the Validator file.\r\n     * @param array  $data     Array of data to validate against.\r\n     * @param array  $rules    Additionnal rules that could come from the controller.\r\n     * @param array  $messages Additionnal messages that could come from the controller.\r\n     *\r\n     * @return bool\r\n     * @throws \\Exception\r\n     */\r\n    public function validFor($action, array $data, array $rules = [], array $messages = [])\r\n    {\r\n        if (!isset($action) || is_array($action) || !is_string($action)) {\r\n            throw new \\Exception('Invalid validation rulset for ' . $action);\r\n        }\r\n\r\n        $rules    = array_key_exists($action, static::$rules)    ? array_merge(static::$rules[$action], $rules) : $rules;\r\n        $messages = array_key_exists($action, static::$messages) ? array_merge(static::$messages[$action], $messages) : $messages;\r\n\r\n        return $this->fire($data, $rules, $messages);\r\n    }\r\n\r\n    /**\r\n     * Trigger validation\r\n     *\r\n     * @param array $data\r\n     * @param array $rules\r\n     * @param array $messages\r\n     * @return bool\r\n     */\r\n    private function fire(array $data, array $rules = [], array $messages = [])\r\n    {\r\n        $validation = $this->validator->make($data, $rules, $messages);\r\n\r\n        if ($validation->fails()) {\r\n            throw new ValidationException($validation);\r\n        }\r\n\r\n        return true;\r\n    }\r\n}\r\n```\r\n\r\nTo be honest with you, there’s not much I can explain about this that hasn’t already been or is covered by the docblocks.\r\n\r\nIt’s really quite simple, you have a class that represents the validation of an object/resource within your system, within there you define named rulesets such as create, update, login as well optionally creating messages for those rulesets following the [Laravel validation message](https://laravel.com/docs/5.2/validation#custom-error-messages) approach and keeping the structure the same as the defined rulesets. This then allows you to call a method with a `validFor{ruleset}` structure and have the data validated and the user automatically returned if they messed it up.\r\n\r\nIt’s actually a really simple approach, it’s streamlined and relatively powerful, it combines the good points from the existing Laravel validation into a nice little approach that you can reuse as many times as you see fit.\r\n\r\nI hope this helps some of you with your application development and hopefully my first article after almost two years break isn’t full of mistakes and unstructured ramblings (more so than normal).",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2016-03-26 15:33:48",
    "deleted_at": null,
    "created_at": "2016-03-26 15:33:48",
    "updated_at": "2018-03-31 07:48:53"
  },
  {
    "id": 3,
    "series_id": null,
    "category_id": 4,
    "parent_id": null,
    "name": "Freelance PHP developer, the return!!",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "freelance-php-developer-return",
    "excerpt": "It has only been a year, but I'm making a return to the world of freelancing.\r\n\r\nFor those of you that don't know, I've been working for CleverCherry for the last year (well, a year as of yesterday). It has been a wonderful year and a wonderful experience. I've made some friends along the way and I've thoroughly enjoyed being a part of their team. I handed my notice in some two months ago and my final day of employment will be the 3rd November, followed by a week of me relaxing, and then it's back into it again.",
    "content": "It has only been a year, but I’m making a return to the world of freelancing.\r\n\r\nFor those of you that don’t know, I’ve been working for [CleverCherry](http://clevercherry.com) for the last year (well, a year as of yesterday). It has been a wonderful year and a wonderful experience. I’ve made some friends along the way and I’ve thoroughly enjoyed being a part of their team. I handed my notice in some two months ago and my final day of employment will be the 3rd November, followed by a week of me relaxing, and then it’s back into it again.\r\n\r\nThe reason for my decision to return to the world of freelancing is that in all honesty, I miss it. After four years of being my own boss it’s hard to get used to situations where I don’t have the say, and for those that know me, I have a problem with that most the time as it is. On top of that, I miss the sort of work I did when I was in London. Don’t get me wrong, I’ve worked on some really interesting things while with CleverCherry, but I’ve always been a fan of functionality driven applications.\r\n\r\nAs of the 13th of November I will be available for freelance projects and contracts alike. I’m also, as always, open to employment should an opportunity turn up on my desk that I absolutely cannot turn down. If you’re looking for a freelance developer to build your app, or a contractor to bolster your team, get in touch over at [Ollie’s Lab](https://ollieslab.io).\r\n\r\nOn a side note, this hopefully means that I’ll have time to actually write articles and work on some of my open source projects!!!",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2017-10-11 00:00:57",
    "deleted_at": null,
    "created_at": "2018-03-25 19:45:57",
    "updated_at": "2018-03-31 08:51:37"
  },
  {
    "id": 4,
    "series_id": null,
    "category_id": 3,
    "parent_id": null,
    "name": "An alternative to Eloquent, Articulate",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "an-alternative-to-eloquent-articulate",
    "excerpt": "Lately I've found myself getting frustrated with Eloquent, needing more than Laravels default ORM offers. I'm a big fan of the DataMapper pattern, but I become disheartened with the overhead and complexity of Doctrine. My time spent with Java has brought out a love for objects, and absolutely everything being objects. With this in mind, I created myself a super basic lightweight ORM named Articulate.",
    "content": "> **NOTE: This article is now out of date! Articulate has come on leaps and bounds since this was written. Check out the [WIP docs](https://sprocketbox.github.io/articulate) until I get chance to write a new article.**\r\n> **There's an [article up now](https://ollieread.com/blog/2018/08/07/how-i-accidentally-created-an-orm-to-avoid-using-eloquent) covering the idea behind Articulate.**\r\n\r\nLately I've found myself getting frustrated with Eloquent, needing more than Laravels default ORM offers. I'm a big fan of the DataMapper pattern, but I become disheartened with the overhead and complexity of Doctrine. My time spent with Java has brought out a love for objects, and absolutely everything being objects. With this in mind, I created myself a super basic lightweight ORM named Articulate.\r\n\r\n## What is Articulate?\r\nThe aim was for an entity based system that sits nicely somewhere between Eloquent and Doctrine. Articulate doesn't enforce any particular database implementation, but comes with an abstract repository for using Laravels DBAL. This has afforded me far more control over the database interactions of my applications.\r\n\r\nThe package itself is available [on packagist](https://packagist.org/packages/sprocketbox/articulate), for those of you that would like to take a look.\r\n\r\nI've been testing the package thoroughly and I've developed it alongside two systems. The most notable of which, is the system that you're currently reading this post on, my personal blog.\r\n\r\n## What makes up Articulate?\r\nArticulate has three core elements, Entities, Mappings and Repositories. \r\n\r\n### Entities\r\nMuch like Eloquents models, Articulate has entities, similar to Doctrine. However, unlike Doctrine, the entities are a bit more fluid. They all extend a base entity providing a very simple `get(string $name)` and `set(string $name, mixed $value)` method. The EntityManager will use individual getters and setters if they are set, for example, `getId()` and `setId(int $id)`.\r\n\r\nNow lets see what an entity representing an admin user would look like;\r\n```php\r\nnamespace Ollieread\\Entities;\r\n\r\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\r\nuse Ollieread\\Articulate\\Concerns\\HasTimestamps;\r\nuse Ollieread\\Articulate\\Entities\\BaseEntity;\r\n\r\nclass Admin extends BaseEntity implements Authenticatable\r\n{\r\n    use HasTimestamps;\r\n\r\n    public function getId(): int {\r\n        return $this->get('id');\r\n    }\r\n\r\n    public function setId(int $value): self {\r\n        $this->set('id', $value);\r\n        return $this;\r\n    }\r\n\r\n    public function getName(): string {\r\n        return $this->get('name');\r\n    }\r\n\r\n    public function setName(string $value): self {\r\n        $this->set('name', $value);\r\n        return $this;\r\n    }\r\n\r\n    public function getEmail(): string {\r\n        return $this->get('email');\r\n    }\r\n\r\n    public function setEmail(string $value): self {\r\n        $this->set('email', $value);\r\n        return $this;\r\n    }\r\n\r\n    public function getPassword(): string {\r\n        return $this->get('password');\r\n    }\r\n\r\n    public function setPassword(string $value): self {\r\n        $this->set('password', $value);\r\n        return $this;\r\n    }\r\n    // Authenticatable methods below\r\n    public function getRememberToken(): string {\r\n        return $this->get('remember_token');\r\n    }\r\n\r\n    public function setRememberToken($value): self {\r\n        $this->set('remember_token', $value);\r\n        return $this;\r\n    }\r\n    \r\n    public function getAuthIdentifierName() {\r\n        return 'id';\r\n    }\r\n    \r\n    public function getAuthIdentifier() {\r\n        return $this->getId();\r\n    }\r\n    \r\n    public function getAuthPassword() {\r\n        return $this->getPassword();\r\n    }\r\n    \r\n    public function getRememberTokenName() {\r\n        return 'remember_token';\r\n    }\r\n}\r\n```\r\n\r\nI've defined getters and setters for all attributes, but you would only really need to do that if you wish to transform the input/output in some way, or if you'd like syntactic sugar. You'll also see that I've implemented the Laravel `Authenticatable` contract.\r\n\r\n### Mappings\r\nThe EntityManager provides the ability to hydrate an entity from a given collection data. The mapping allows you to map the attribute in the entity, to the column/index in the provided data, as well as the data type.\r\n\r\nThe mapping for the above entity would be as follows;\r\n```php\r\nnamespace Ollieread\\Mappings;\r\n\r\nuse Ollieread\\Articulate\\EntityMapping;\r\nuse Ollieread\\Articulate\\Contracts\\Mapping;\r\nuse Ollieread\\Entities\\Admin;\r\nuse Ollieread\\Repositories\\AdminRepository;\r\n\r\nclass AdminMapping extends EntityMapping\r\n{\r\n    public function entity(): string {\r\n        return Admin::class;\r\n    }\r\n\r\n    public function table(): string {\r\n        return 'admins';\r\n    }\r\n\r\n    public function map(Mapping $mapper) {\r\n        $mapper->setKey('id');\r\n        $mapper->setRepository(AdminRepository::class);\r\n        $mapper->mapInt('id')->setImmutable();\r\n        $mapper->mapString('name');\r\n        $mapper->mapString('email');\r\n        $mapper->mapString('password');\r\n        $mapper->mapString('remember_token');\r\n        $mapper->mapTimestamp('created_at');\r\n        $mapper->mapTimestamp('updated_at');\r\n    }\r\n}\r\n```\r\n\r\nIt's a fairly simple mapping as far as they go. We map the `id` column as an `int` meaning that when retrieving, this value will be cast to an `int`. We also set this field as immutable, so that any changes (`set('id', 20)` || `setId(20)`) are not persisted. Other notable mappings would be the timestamps, meaning that `$entity->getCreatedAt()` will return an instance of `Carbon`.\r\n\r\n### Repositories\r\nAll Articule entities should have a repositorty. The repository follows the pattern by the same name, and exists to retrieve entities. Two abstract repositories are provided, `EntityRepository`, the generic one, and `DatabaseRepository` which has built in support for Laravels query builder.\r\n\r\nThe repository for the admin entity would be as follows;\r\n```php\r\nnamespace Ollieread\\Repositories;\r\n\r\nuse Illuminate\\Contracts\\Auth\\Authenticatable;\r\nuse Ollieread\\Articulate\\Contracts\\EntityAuthRepository;\r\nuse Ollieread\\Articulate\\Repositories\\DatabaseRepository;\r\n\r\nclass AdminRepository extends DatabaseRepository implements EntityAuthRepository \r\n{\r\n    public function retrieveById($identifier): ?Authenticatable {\r\n        return $this->getOneBy('id', $identifier);\r\n    }\r\n    \r\n    public function retrieveByToken($identifier, $token): ?Authenticatable {\r\n        $result = $this\r\n            ->query($this->entity())\r\n            ->where('id', '=', $identifier)\r\n            ->where('remember_token', '=', $token)\r\n            ->first();\r\n\r\n        if ($result) {\r\n            return $this->hydrate($result);\r\n        }\r\n\r\n        return null;\r\n    }\r\n    \r\n    public function updateRememberToken(Authenticatable $user, $token): void {\r\n        $id = $user->getAuthIdentifier();\r\n\r\n        $this->query($this->entity())\r\n            ->where('id', '=', $id)\r\n            ->update(['remember_token' => $token]);\r\n    }\r\n    \r\n    public function retrieveByCredentials(array $credentials): ?Authenticatable {\r\n        $credentials = array_except($credentials, ['password']);\r\n\r\n        $query = $this->query($this->entity());\r\n\r\n        foreach ($credentials as $key => $value) {\r\n            $query->where($key, '=', $value);\r\n        }\r\n\r\n        $result = $query->first();\r\n\r\n        if ($result) {\r\n            return $this->hydrate($result);\r\n        }\r\n\r\n        return null;\r\n    }\r\n}\r\n```\r\n\r\nArticulates auth support actually allows you full control through repositories. You can setup several guards, and have totally different logic for the retrieval of users, all through the `EntityAuthRepository` contract.\r\n\r\n## What Next?\r\nThis is just a brief overview of what Articulate is, but more information can be found [within the README](https://github.com/ollieread/articulate).\r\n\r\nI'll hopefully be covering this more in the future, with tutorials covering the Articulate approach.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-04-17 00:00:50",
    "deleted_at": null,
    "created_at": "2018-04-06 18:08:50",
    "updated_at": "2018-08-07 18:59:13"
  },
  {
    "id": 5,
    "series_id": null,
    "category_id": 1,
    "parent_id": null,
    "name": "Using Repositories with Laravel",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "using-repositories-with-laravel",
    "excerpt": "The repository pattern is one that appears to polarize developers, with half swearing by and half swearing against. It's also something that seems to have been spoken about a lot, though I feel that more often than not, it's an over complicated over engineered approach.",
    "content": "The repository pattern is one that appears to polarize developers, with half swearing by and half swearing against. It's also something that seems to have been spoken about a lot, though I feel that more often than not, it's an over complicated over engineered approach.\r\n\r\nI've spent a good amount of time working with repositories, and these days, it's rare that my projects don't have them. I've also encountered a lot of projects, written by others, with repositories straight out of a tutorial, that is to say, full of interfaces.\r\n\r\n### What is the repository pattern?\r\n\r\nTo quote *Patterns of Enterprise Application Architecture*;\r\n\r\n> Mediates between the domain and data mapping layers using a collection-like interface for accessing domain objects.\r\n\r\nSimply put, a repository is an abstraction of the interaction with a data source, and/or the persistence layer. The idea is that your database interactions are sufficiently abstracted as to be easily modified and swapped out with little to no overhead.\r\n\r\nThe approach itself is amazingly useful, for applications of all sizes.\r\n\r\n### Why should I use a repository?\r\n\r\nSimply put, because you want your code to be more manageable. Sure you can add lots of methods to your models, but if you've ever looked at the full structure of a model, they're already pretty full.\r\n\r\n### The interface approach\r\n\r\nA lot of tutorials will approach repositories in Laravel by having you create an interface per repository, and then binding your concrete instance to the interface, using Laravels IoC container.\r\n\r\nThe goal with this approach, is that you've defined the API of your repository, and should you need to change data source in the future, you can quite easily create a new repository and implement your interface. This is all good and well in principal, but it'll end up filling your application with interfaces, and somewhat over complicating the process.\r\n\r\nThe chances of you changing your data source at a later date are pretty low. On top of that, most modern IDEs will let you very easily extract an interface from a repository, so you can create one when you need one. Further more, even with the best planning in the world, your repositories will not be the same at the end of the project, as they were at the start. This means that you're constantly having to update the interfaces, as well as the repositories themselves.\r\n\r\n### A simpler approach\r\n\r\nThe most common reason for not using repositories, is that it's a lot of extra effort, for no real benefit. The answer to that, is to simplify the approach.\r\n\r\nI have a package that I use in almost all Laravel projects, I called it [my toolkit](https://packagist.org/packages/ollieread/laravel-toolkit). Amongst other things, it contains a base repository that I use for everything that uses Eloquent. It's relatively simple, and the source can be [viewed here](https://github.com/ollieread/toolkit/blob/master/src/Repositories/BaseRepository.php).\r\n\r\nWhen I start a new project, I can create a fully functional repository that works for most cases by simply extending my base repository like so;\r\n\r\n```php\r\n/**\r\n * @method Post make()\r\n * @method null|Post getOneById(int $id)\r\n */\r\nclass PostRepository extends BaseRepository\r\n{\r\n    protected $model = Post::class\r\n}\r\n```\r\n\r\nThe above, is a legitimate repository, lifted directly from a working codebase. Because of the helper methods (you'll see them later on in this post), I'm able to perform almost all of the actions I need, using the generic approaches. Should I require a specific method that does something different, I can define it here.\r\n\r\nYou'll also notice that I redefined some of the methods from the base repository, using the php docblocks. The reason for this is so that my IDE knows the exact instance expected.\r\n\r\nLets break down this base repository.\r\n\r\n```php\r\nabstract class BaseRepository\r\n{\r\n    /**\r\n     * @var string\r\n     */\r\n    protected $model;\r\n    /**\r\n     * @return Model\r\n     */\r\n    protected function make(): Model\r\n    {\r\n        return new $this->model;\r\n    }\r\n    /**\r\n     * @return \\Illuminate\\Database\\Eloquent\\Builder\r\n     */\r\n    protected function query(): Builder\r\n    {\r\n        return $this->make()->newQuery();\r\n    }\r\n}\r\n```\r\n\r\nYou'll notice that the class is `abstract` so that it must be extended, and the child classes should redefine the `$model` property with the class name of the model in question.\r\n\r\nNext you'll see two methods, `make()` and `query()`. If not by their names, the body of these methods provides a sufficient explanation as to what they do.\r\n\r\nRealistically, this is all that you need for a repository, and anything on top of this would just be nice helper methods. An example implementation of this would be as follows;\r\n\r\n```php\r\nclass PostRepository extends BaseRepository\r\n{\r\n    protected $model = Post::class;\r\n\r\n    public function getPaginated(int $count = 20): LengthAwarePaginator\r\n    {\r\n        return $this->query()\r\n            ->orderBy('created_at', 'desc')\r\n            ->paginate($count);\r\n    }\r\n}\r\n```\r\n\r\nThe class itself provides a nice method for creating a new instance of the model in question, as well as query builder instance for it. Some may argue that the `query()` method isn't needed, as technically the Model will pass it through, but I'm a fan of IDEs being able to detect what's happening. Magic is all good and well in small doses, but I prefer to be aware of exactly what's going on.\r\n\r\nIf you've taken a look at the source of my repository, you'll also notice a few other methods in there. These methods are purely to simplify my life, and implementing things like this, could aid you too.\r\n\r\nThe first method we have is the `getId()` method.\r\n\r\n```php\r\nprotected function getId($model): int\r\n{\r\n    return $model instanceof Model ? $model->getKey() : $model;\r\n}\r\n```\r\n\r\nSometimes, you may want to pass in either the full model, or just the id. There are plenty of reasons for wanting to do this, which is why this method was born. It's essentially a normalisation method, that will return the key (within reason). The assumption is that the value is either a model, or the id/key. I can be certain this is the case, because of how the code is accessed.\r\n\r\n```php\r\npublic function persist(array $input, $model = null)\r\n{\r\n    if ($model) {\r\n        $model = $this->getOneById($model);\r\n    } else {\r\n        $model = $this->make();\r\n    }\r\n    if ($model instanceof $this->model) {\r\n        $model->fill($input);\r\n        if ($model->save()) {\r\n            return $model;\r\n        }\r\n    }\r\n    return null;\r\n}\r\n```\r\n\r\nThis is a recent addition to my base repository, but I find it very useful. One of things I always do with my Eloquent models, is make sure the `$fillable` array is correctly configured. I know that the processing of my model data has happened outside of the repository (because it's not the repositories job), so I can pass an array to the method, to persist the data to the database. If I was performing a create action, the second argument would be null, and if it was an update, I'd pass in the model (or the id).\r\n\r\nThis isn't strictly needed, but it's helpful. It has made partial updates simpler, and has stopped me having to write specific create and/or update methods.\r\n\r\n```php\r\npublic function delete($model): ?bool\r\n{\r\n    if ($model instanceof Model) {\r\n        return $model->delete();\r\n    }\r\n    $id    = $model;\r\n    $model = $this->make();\r\n    return $model->newQuery()\r\n        ->where($model->getKeyName(), $id)\r\n        ->delete();\r\n}\r\n```\r\n\r\nFor every 10 repositories I write, I probably need 1, maybe 2 custom delete methods. For the rest, I just use this inherited method. Simple and tidy.\r\n\r\n```php\r\npublic function getBy(): ?Collection\r\n{\r\n    $model = $this->query();\r\n    if (\\func_num_args() === 2) {\r\n        list($column, $value) = \\func_get_args();\r\n        $method = \\is_array($value) ? 'whereIn' : 'where';\r\n        $model  = $model->$method($column, $value);\r\n    } elseif (\\func_num_args() === 1) {\r\n        $columns = func_get_arg(0);\r\n        if (\\is_array($columns)) {\r\n            foreach ($columns as $column => $value) {\r\n                $method = \\is_array($value) ? 'whereIn' : 'where';\r\n                $model  = $model->$method($column, $value);\r\n            }\r\n        }\r\n    }\r\n    return $model->get();\r\n}\r\n```\r\n\r\nThis method is a super useful helper function that lets me retrieve multiple rows by basic column => value conditions. For example, I can do the following;\r\n\r\n```php\r\n$inactive = $repository->getBy(['active' => 0]);\r\n```\r\n\r\nThis method is actually accompanied by two others;\r\n\r\n```php\r\npublic function getOneBy(): ?Model\r\n{\r\n    $model = $this->query();\r\n    if (\\func_num_args() === 2) {\r\n        list($column, $value) = \\func_get_args();\r\n        $method = \\is_array($value) ? 'whereIn' : 'where';\r\n        $model  = $model->$method($column, $value);\r\n    } elseif (\\func_num_args() === 1) {\r\n        $columns = \\func_get_args();\r\n        if (\\is_array($columns)) {\r\n            foreach ($columns as $column => $value) {\r\n                $method = \\is_array($value) ? 'whereIn' : 'where';\r\n                $model  = $model->$method($column, $value);\r\n            }\r\n        }\r\n    }\r\n    return $model->first();\r\n}\r\n\r\npublic function __call(string $name, array $arguments = [])\r\n{\r\n    if (\\count($arguments) > 1) {\r\n        // TODO: Should probably throw an exception here\r\n        return null;\r\n    }\r\n    if (0 === strpos($name, 'getBy')) {\r\n        return $this->getBy(snake_case(substr($name, 5)), $arguments[0]);\r\n    }\r\n    if (0 === strpos($name, 'getOneBy')) {\r\n        $column = snake_case(substr($name, 8));\r\n        return \\call_user_func([$this->make(), 'where'], $column, $arguments[0])->first();\r\n    }\r\n}\r\n```\r\n\r\nThe `getOneBy` method is the sister of the `getBy`, essentially performing a `first()` on the query, rather than a `get()`.\r\n\r\nThe `__call` method allows you to do things like `getByActive(0)`, `getOneById(1)` and so on and so forth. The magic method mapping only allows for one condition. As I write this, I also realise that the `getOneBy` and `getBy` can abstracted out, as there's some duplicate code there.\r\n\r\n### Conclusion\r\n\r\nEither using a base repository that's already available, or creating yourself one, can simplify the process of using a repository. There's no need to complicate everything with as many interfaces as there are repositories.\r\n\r\nI hope this has helped those of you there were on the fence or unsure. If you have any further questions, feel free to leave a comment.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-04-06 20:34:49",
    "deleted_at": null,
    "created_at": "2018-04-06 21:34:49",
    "updated_at": "2018-04-06 22:15:46"
  },
  {
    "id": 6,
    "series_id": null,
    "category_id": 3,
    "parent_id": null,
    "name": "Treating APIs like any other data source",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "treating-apis-like-any-other-data-source",
    "excerpt": "APIs are, after all, another data source, so why not treat them like one?",
    "content": "When dealing with third party APIs we don't really care about the endpoints for the data, or how exactly the implementation needs to take place, we just care about the resources returned by the API.\r\n\r\n## Data source abstraction\r\nData source abstraction has been an interest of mine for a while now, ever since I authored the initial version of [Articulate](https://github.com/sprocketbox/articulate), a data source agnostic entity mapper. Unfortunately, the initial versions of Articulate didn't work exactly as I had planned, and I have since reworked the entire package to better support different data sources. With the introduction of sources, I've managed to create a uniform way to interact with data, meaning that my application logic can deal with entities regardless of whether they've come from a database, an API or a file.\r\n\r\nThe first source that I built support for is called `Illuminate` and essentially wraps the Laravel query builder in a tiny abstraction layer, allowing Articulate entities to use it as its data source.\r\n\r\n## API wrapper abstraction\r\nNow, my second source was a little bit more complicated, as I wanted to abstract out API wrappers so that I could interact with them in the same manner as I can with the database using the `Illuminate` source. Rather than build out some mammoth source that did this, I decided to split this out into its own package.\r\n\r\nThis package is called [Respite](https://github.com/sprocketbox/respite), and if you're wondering why that name, it's because `Respite` is a synonym for `Rest`. This package in its initial rudimentary form allows me to register OAuth2 providers so that I may use a generic request builder to query the API. An example provider is as follows;\r\n\r\n```php\r\nnamespace Sprocketbox\\Respite\\Providers\\GitHub;\r\n\r\nuse GuzzleHttp\\Client;\r\nuse Sprocketbox\\Respite\\Providers\\OAuth2Provider;\r\nuse Sprocketbox\\Respite\\Request\\Builder;\r\n\r\nclass GitHubProvider extends OAuth2Provider {\r\n    public function newBuilder(): Builder {\r\n        $client = new Client(['base_uri' => $this->config['base_url'] ?? '']);\r\n        if (! $this->accessToken) {\r\n            throw new \\RuntimeException('No access token provided');\r\n        }\r\n        return new Builder($client, ['Authorization' => 'Bearer ' . $this->accessToken]);\r\n    }\r\n}\r\n```\r\n\r\nThe only other method available on the provider is `setAccessToken(string|AccessToken $accessToken): self`, which allows me to set the access token for the current builder.\r\n\r\nWith this provider registered like so;\r\n\r\n```php\r\nrespite()->extend('github', GithubProvider::class);\r\n```\r\n\r\nI am able to create a nice little builder that lets me interact with the GitHub API.\r\n\r\n```php\r\n$respite = app(Respite::class);\r\n\r\n$response = $respite\r\n    ->for('github')\r\n    ->setAccessToken('ACCESS_TOKEN')\r\n    ->get('/users/{username}/repos', ['ollieread'])\r\n    ->contents();\r\n```\r\n\r\nIn the above code, `$response` will contain a collection of arrays, each representing a GitHub repository resource.\r\n\r\nThis is all good and well, but I don't want arrays, I want entities.\r\n\r\n## APIs as abstract data sources\r\nUsing my newly created [Respite](https://github.com/sprocketbox/respite) package I was able to build a source into [Articulate](https://github.com/sprocketbox/articulate) that allowed my basic GitHub implementation to have entities and even repositories, allowing me to do away with API endpoint references and deal with exactly what I wanted, the resources.\r\n\r\nFirst, I created myself an entity to represent the GitHub `User` resource;\r\n\r\n```php\r\nnamespace Sprocketbox\\Github\\Entities;\r\n\r\nuse Sprocketbox\\Articulate\\Entities\\Entity;\r\n\r\n/**\r\n * Class User\r\n *\r\n * @property-read int       $id\r\n * @property string         $login\r\n * @property string         $nodeId\r\n * @property string         $avatarUrl\r\n * @property string         $gravatarId\r\n * @property string         $url\r\n * @property string         $htmlUrl\r\n * @property string         $followersUrl\r\n * @property string         $followingUrl\r\n * @property string         $gistsUrl\r\n * @property string         $starredUrl\r\n * @property string         $subscriptionsUrl\r\n * @property string         $organizationsUrl\r\n * @property string         $reposUrl\r\n * @property string         $eventsUrl\r\n * @property string         $receivedEventsUrl\r\n * @property string         $type\r\n * @property bool           $siteAdmin\r\n * @property string         $name\r\n * @property string         $company\r\n * @property string         $blog\r\n * @property string         $location\r\n * @property string         $email\r\n * @property bool           $hireable\r\n * @property string         $bio\r\n * @property int            $publicRepos\r\n * @property int            $publicGists\r\n * @property int            $followers\r\n * @property int            $following\r\n * @property \\Carbon\\Carbon $createdAt\r\n * @property \\Carbon\\Carbon $updatedAt\r\n *\r\n * @package Sprocketbox\\Github\\Entities\r\n */\r\nclass User extends Entity\r\n{\r\n}\r\n```\r\n\r\nThen I created a mapper so that the attributes could be correctly mapped.\r\n\r\n```php\r\nnamespace Sprocketbox\\Github\\Mappers;\r\n\r\nuse Sprocketbox\\Articulate\\Contracts\\EntityMapping;\r\nuse Sprocketbox\\Articulate\\Entities\\EntityMapper;\r\nuse Sprocketbox\\Github\\Entities\\User;\r\nuse Sprocketbox\\Github\\Repositories\\UserRepository;\r\n\r\nclass UserMapper extends EntityMapper {\r\n\r\n    public function entity(): string {\r\n        return User::class;\r\n    }\r\n\r\n    public function source(): string {\r\n        return 'respite';\r\n    }\r\n\r\n    /**\r\n     * @param \\Sprocketbox\\Articulate\\Sources\\Respite\\RespiteEntityMapping $mapping\r\n     */\r\n    public function map(EntityMapping $mapping) {\r\n        $mapping->setKey('id');\r\n        $mapping->setProvider('github');\r\n        $mapping->setRepository(UserRepository::class);\r\n        $mapping->int('id');\r\n        $mapping->string('login');\r\n        $mapping->string('node_id');\r\n        $mapping->string('avatar_url');\r\n        $mapping->string('gravatar_id');\r\n        $mapping->string('url');\r\n        $mapping->string('html_url');\r\n        $mapping->string('followers_url');\r\n        $mapping->string('following_url');\r\n        $mapping->string('gists_url');\r\n        $mapping->string('starred_url');\r\n        $mapping->string('subscriptions_url');\r\n        $mapping->string('organizations_url');\r\n        $mapping->string('repos_url');\r\n        $mapping->string('events_url');\r\n        $mapping->string('received_events_url');\r\n        $mapping->string('type');\r\n        $mapping->bool('site_admin');\r\n        $mapping->string('name');\r\n        $mapping->string('company');\r\n        $mapping->string('blog');\r\n        $mapping->string('location');\r\n        $mapping->string('email');\r\n        $mapping->bool('hireable');\r\n        $mapping->string('bio');\r\n        $mapping->int('public_repos');\r\n        $mapping->int('public_gists');\r\n        $mapping->int('followers');\r\n        $mapping->int('following');\r\n        $mapping->timestamp('created_at', 'Y-m-d\\TH:i:s\\Z');\r\n        $mapping->timestamp('updated_at', 'Y-m-d\\TH:i:s\\Z');\r\n    }\r\n}\r\n```\r\n\r\nThen I created a nice and simple repository;\r\n\r\n```php\r\nnamespace Sprocketbox\\Github\\Repositories;\r\n\r\nuse Sprocketbox\\Articulate\\Sources\\Respite\\RespiteRepository;\r\nuse Sprocketbox\\Github\\Entities\\User;\r\nuse Sprocketbox\\Respite\\Request\\Builder;\r\n\r\n/**\r\n * Class UserRepository\r\n *\r\n * @method \\Sprocketbox\\Github\\Entities\\User|null getOne(Builder $builder, ?string $key = null)\r\n * @method \\Sprocketbox\\Articulate\\Support\\Collection get(Builder $builder, ?string $key = null)\r\n *\r\n * @package Sprocketbox\\Github\\Repositories\r\n */\r\nclass UserRepository extends RespiteRepository\r\n{\r\n    /**\r\n     * @return null|\\Sprocketbox\\Github\\Entities\\User\r\n     * @throws \\GuzzleHttp\\Exception\\GuzzleException\r\n     */\r\n    public function getCurrent(): ?User\r\n    {\r\n        return $this->getOne($this->builder()->get('/user'));\r\n    }\r\n}\r\n```\r\n\r\nNow all I need to do is test the implementation;\r\n\r\n```php\r\nentities()->registerEntity(new UserMapper);\r\nrespite('github')->setAccessToken('ACCESS_TOKEN');\r\n$userRepository = app(UserRepository::class);\r\n$current = $userRepository->getCurrent();\r\n```\r\n\r\nNow the `$current` entity contains an instance of my `User` entity, with all of the data populated from the GitHub API and cast accordingly thanks to the mapping.\r\n\r\n## What's next?\r\nNow that I have proved that there is at least both a theoretical and practical approach to this problem, I'm going to keep digging and experimenting.\r\n\r\nAs part of this little experiment I'm going to build out the GitHub package, as well as look into a few others (namely Discord as I need one for a pet project). I'm also going to keep testing the implementation and the theory, as well as improving upon both [Articulate](https://github.com/sprocketbox/articulate) , and [Respite](https://github.com/sprocketbox/respite).\r\n\r\nIf you have any APIs you'd like me to use as a test case for these packages let me know. I'm also open to any suggestions and feedback.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-07-19 23:38:28",
    "deleted_at": null,
    "created_at": "2018-07-19 23:40:37",
    "updated_at": "2018-07-20 01:11:45"
  },
  {
    "id": 7,
    "series_id": null,
    "category_id": 1,
    "parent_id": null,
    "name": "Laravel multi-tenancy, avoiding over engineering",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "laravel-multi-tenancy-avoiding-over-engineering",
    "excerpt": "Multi-tenancy seems to be a hot topic at the moment, with many hoping that Laravel Nova was going to solve all of their issues. There are a lot of packages out there that aid you with your multi-tenanted endeavour, but it doesn't have to be that complicated. Honestly.",
    "content": ":::info\r\nI'm currently working on a <a href=\"https://multitenancy.dev\" target=\"_blank\">Multitenancy with Laravel</a> course and package that includes the topics covered in this article, and more.\r\n:::\r\n\r\n[[toc]]\r\n\r\n\r\nFor those of you that follow my posts, packages or ramblings on Twitter, you'd have noticed that I am a big fan of a multi-tenant systems, specifically those that use subdomains. You may even be aware that I had a package for this very purpose. The package itself has been dormant for a while and has as of yesterday, been abandoned. The primary reason for this is that the layer of abstraction that it added, although simple, was barely worth it.\r\n\r\nIn this article I'm going to go through the ins and outs of creating a multi-tenant system with Laravel, to show that it really isn't that big a deal.\r\n\r\n# What is multi-tenancy?\r\nTo quote the [multi-tenancy](https://en.wikipedia.org/wiki/Multitenancy) article on Wikipedia;\r\n\r\n> The term \"software multi-tenancy\" refers to a software architecture in which a single instance of software runs on a server and serves multiple tenants. A tenant is a group of users who share a common access with specific privileges to the software instance. With a multi-tenant architecture, a software application is designed to provide every tenant a dedicated share of the instance - including its data, configuration, user management, tenant individual functionality and non-functional properties. Multi-tenancy contrasts with multi-instance architectures, where separate software instances operate on behalf of different tenants.\r\n\r\nTo put this in simple terms, a multi-tenanted system is one that appears to be a different system when accessed as a different tenant. \r\n\r\nA good example of this would be the Atlassian products with cloud hosting. When I go to `myusername.atlassian.net/wiki` I see Confluence, except it has my data, my themes, my styles and my information. If you were to go `anotheruser.atlassian.net/wiki`, you'd see Confluence, but it would all be configured as they have configured it. This particular example uses domain based tenant identification, specifically, subdomains. The first part of the URL tells Confluence that I want to access the content for `myusername`, and the internal code prevents me from accessing any content or information that isn't linked with me account in some way.\r\n\r\n### What is multi-instance?\r\nMulti-instance systems are similar to multi-tenancy, except that rather than have a single instance of the software serving all of the tenants, there is an instance per tenant. This is far more complicated to achieve, but it opens up a lot of possibilities.\r\n\r\nWith a multi-instance system, you can have particular features built into a specific tenants instance, allowing for completely custom features. You can do this with multi-tenanted systems, but then your codebase becomes a complete mess, and it's not entirely that easy to do properly.\r\n\r\n### So which do I use?\r\nBoth multi-tenant and multi-instance approaches have their shares of pros and cons.\r\n\r\n**Use Multi-Instance if...** \r\nYou want your tenants to have custom bespoke functionality, such as additional features. I'm not talking about tenants having different feature sets, I'm talking about features and functionality that only a particular tenant has, where the code was written specifically for them and doesn't work for other tenants.\r\n\r\n**Use Multi-Tenant if...** \r\nEssentially, you should use multi-tenant if you don't want the above (that's why I put that one first).\r\n\r\nThe above are designed to be guidelines, as ultimately the choice is yours (or the stakeholders), and I've been intentionally generic because it'd be possible to list all possible use cases.\r\n\r\n# Implementing multi-tenancy\r\nSeeing as you're now reading this, I can only assume that you've decided to go for the multi-tenanted approached, so lets look into the different ways we can achieve this.\r\n\r\n### I found this package for Laravel that provides multi-tenant support\r\nNow, I can't speak for every multi-tenant package, but I can safely say that of those that I have encountered, none should be used. Yes, that does include my now abandoned package.\r\n\r\nWhy you ask? Well let me tell you. Over the years of working with multi-tenant systems I researched a lot, not just the concepts of multi-tenancy, but the code that was available out there. After all, multi-tenancy does seem quite daunting when you get into it. The truth is, it's really not that complicated, and all of the packages I found did something or other that just reeked of bad practice, or was over engineered. Here are a couple of things that I found, that should be avoided.\r\n\r\n**Nginx/Apache VirtualHost modifications**\r\n\r\nA few packages out there actually edit your HTTP server configurations as and when a new tenant is created. This is absolutely a no go. Besides the fact that it's completely pointless, as you can achieve the same result by configuring your server correctly (I will cover this a bit later on), having your web server edit configuration files, specifically core configuration files that you need to run this service, is a HUGE issue, with potentially catastrophic results.\r\n\r\n**Merging responsibility**\r\n\r\nI understand that not many of you will be quite as fond of 'separation of responsibility' as I am, but it's definitely something to consider. Besides the fact that I genuinely believe that this principal/concept be held to, there are some cases where it just shows shody code. If you're using some sort of URL based tenant identification, Laravels `Request` object will be at the core of that, and will provide you with the necessary details. It is a trivial task to get what you need from this object and pass that a long down the chain, so there's absolutely no need to pass around the entire instance. If the `Request` object is being injected into models, scopes, repositories or generally anything outside of the HTTP layer (middleware, controllers, etc), avoid it. What else could be lurking in the code?\r\n\r\n**Over Engineering**\r\n\r\nI fell victim to this with my package, though not quite to the extent that I have seen. Later on in this article I'm going to give you some code to show how to implement the different methods of multi-tenancy, and you'll see that they don't involve much code at all. The majority of the packages I have seen over engineer their approaches to the nth level. You may find yourself saying 'But they need be generic, and cover every eventuality'. They do, but again, that can achieved with very little code.\r\n\r\n### But multi-tenancy is complicated\r\nAs mentioned above, it's really not. It can seem very daunting when reading up, but then again, any pattern will, just look at repositories.\r\n\r\nGenerally there are a couple of questions you should answer before writing any code.\r\n\r\n**How will tenants be identified?**\r\n\r\n**Do my tenants need separate databases?**\r\n\r\nThere are many ways for a tenant to be identified, but for the purpose of this article I'll be covering;\r\n\r\n- URL identification *(Identified by part of the URL)*\r\n    - Domain\r\n    - Subdomain\r\n    - Path\r\n\r\nI will also be covering both single and multi-database setups.\r\n\r\nNow let's take a look at some code.\r\n\r\n# Identifying the tenant\r\nThe core part of any multi-tenant system is the tenant, so identifying which tenant the request is for is paramount. \r\n\r\nAll of the following code will assume the existence of a Tenant model (`App\\Tenant`). Before we get into the specific methods of identifying the tenant, we need to create some base classes that all of the methods will use.\r\n\r\n### Tenant Manager\r\nWe need a way to store the current tenant so that it can be accessed where it is needed. We're going to do this by creating a super simple tenant manager, that we will bind to Laravels IoC containerso that we can access the same instance every time we need it.\r\n\r\n```php\r\nnamespace App\\Services;\r\n\r\nuse App\\Tenant;\r\n\r\nclass TenantManager {\r\n    /*\r\n     * @var null|App\\Tenant\r\n     */\r\n     private $tenant;\r\n   \r\n    public function setTenant(?Tenant $tenant) {\r\n        $this->tenant = $tenant;\r\n        return $this;\r\n    }\r\n    \r\n    public function getTenant(): ?Tenant {\r\n        return $this->tenant;\r\n    }\r\n    \r\n    public function loadTenant($identifier): bool {\r\n        // Identify the tenant here\r\n    }\r\n }\r\n```\r\n\r\nThis is a fairly simple class, as we don't really need anything complex. So what do we have?\r\n\r\n- We have a getter (`getTenant()`) that returns the current tenant or null\r\n- We have a setter (`setTenant(?Tenant $tenant)`) in case we need to manually set (or unset) the tenant\r\n- We have a method for loading the tenant (`loadTenant($identifier)`) \r\n\r\nThe `loadTenant($identifier)` method is intentionally empty, as that will be the method that we populate for each of our identification methods.\r\n\r\nLaravel has a powerful IoC container that lets us bind objects for injection. Typically this is used to bind a concrete for a given interface, but it can also be used to resolve certain instances that aren't just simply instantiated. If you're new to the container, you can read the documentation [here](https://laravel.com/docs/5.6/container#binding-basics). Here, we're going to leverage the power of this container to;\r\n\r\n- Make sure we receive the same instance of `TenantManager` \r\n- Avoid having to call `TenantManager->getTenant()` everywhere.\r\n\r\nEither open up `AppServiceProvider` (`app/Providers/AppServiceProvider.php`) or create and open a new service provider (You can use `php artisan make:provider TenantServiceProvider`). Go to the `register()` method and add the following;\r\n\r\n```php\r\n$manager = new TenantManager;\r\n\r\n$this->app->instance(TenantManager::class, $manager);\r\n$this->app->bind(Tenant::class, function () use ($manager) {\r\n    return $manager->getTenant();\r\n});\r\n```\r\n\r\nNow, when we type hint as `TenantManager` we will receive the same instance, the one that will be populated with the current tenant. We can also now type hint with `Tenant` if we want to retrieve the current tenant, without injecting the manager and calling the get tenant method.\r\n\r\n### Identification Middleware\r\nIf we're going ahead with URL identification for tenants, we're going to create some middleware to simplify the whole process. Go to your terminal and type `php artisan make:middleware IdentifyTenant`. Once this is done open up `IdentifyTenant` (`app/Http/Middleware/IdentifyTenant.php`) and modify it so it looks like the following;\r\n\r\n```php\r\nnamespace App\\Http\\Middleware;\r\n\r\nuse Closure;\r\nuse App\\Services\\TenantManager;\r\n\r\nclass IdentifyTenant\r\n{\r\n    /**\r\n    * @var App\\Services\\TenantManager\r\n    */\r\n    protected $tenantManager;\r\n    \r\n    public function __construct(TenantManager $tenantManager)\r\n    {\r\n        $this->tenantManager = $tenantManager;\r\n    }\r\n\r\n    /**\r\n     * Handle an incoming request.\r\n     *\r\n     * @param  \\Illuminate\\Http\\Request  $request\r\n     * @param  \\Closure  $next\r\n     * @return mixed\r\n     */\r\n    public function handle($request, Closure $next)\r\n    {\r\n        return $next($request);\r\n    }\r\n}\r\n```\r\n\r\nAll we did here was add a constructor and a property, so that our `TenantManager` instance is injected.\r\n\r\nNow we just need to wrap our tenant routes in a group with our newly created middleware.\r\n\r\n```php\r\nRoute::group([\r\n    'middleware' => \\App\\Http\\Middleware\\IdentifyTenant::class,\r\n    'as'         => 'tenant:',\r\n], function () {\r\n    // Tenant routes here\r\n});\r\n```\r\n\r\nI added an `as` here so that all tenant route names are prefixed with `tenant:`. Trust me, you'll find this useful.\r\n\r\nWe now have our tenant manager, and our identification middleware, lets actually identify some tenants.\r\n\r\n### Domain Identification\r\nIf you're familiar with Laravel routes you may be tempted to use the `domain` attribute for route groups, but we really don't need that here. If you plan to serve a generic section of your system, such as the initial landing and error page, you should wrap those routes in a group using the `domain` you want them to be accessed from.\r\n\r\nFirst we want to edit our `IdentifyTenant::handle` method;\r\n\r\n```php\r\npublic function handle($request, Closure $next)\r\n{\r\n    if ($this->tenantManager->loadTenant($request->getHost())) {\r\n        return $next($request);\r\n    }\r\n    \r\n    throw new NotFoundHttpException;\r\n}\r\n```\r\n\r\nHere we are grabbing the domain name `$request->getHost()` and passing it to `$this->tenantManager->loadTenant()` which we know will return a bool, then if it succeeds, containing down the middleware chain, or throwing a 404 if no tenant was found. We're doing this all inline inside an if, as there's no need to create unnecessary variables.\r\n\r\nNext we're going to edit `TenantManager::loadTenant()` to perform the identification.\r\n\r\n```php\r\npublic function loadTenant(string $identifier): bool {\r\n    $tenant = Tenant::query()->where('domain', '=', $identifier)->first();\r\n    \r\n    if ($tenant) {\r\n        $this->setTenant($tenant);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n```\r\n\r\nHere we're taking the string identifier, and retrieving the first database match for it. I'm assuming that the tenant model has a `domain` column that contains the domain, and if it does, I'm confident that it has a unique index (If that was too subtle, add a unique index).\r\n\r\nThere we go, domain based tenant identification done, onto the next.\r\n\r\n### Subdomain Identification\r\nSubdomain identification is almost identical to the domain identification, and the rule about not using the `domain` group attribute, still applies.\r\n\r\nFirst we're going to add an env variable to both `.env` and `.env.example`.\r\n\r\n```\r\nTENANT_DOMAIN=myawesomeapp.com\r\n```\r\n\r\nWe're going to use this to identify whether the current URL is a tenant subdomain.\r\n\r\nNext we want to edit our `IdentifyTenant::handle` method;\r\n\r\n```php\r\npublic function handle($request, Closure $next)\r\n{\r\n    $host = $request->getHost();\r\n    $pos = strpos($host, env('TENANT_DOMAIN'));\r\n    \r\n    if ($pos !== false && $this->tenantManager->loadTenant(substr($host, 0, $pos - 1)) {\r\n        return $next($request);\r\n    }\r\n    \r\n    throw new NotFoundHttpException;\r\n}\r\n```\r\n\r\nWhile this is very similar to the domain identification, the difference is the important part. After getting the host we find the position of the `TENANT_DOMAIN` within it, using `strpos()`. We then make sure that the result of this isn't _EXACTLY_ false (`strpos` can return 0, with is equal to false, where as a return of false means it didn't find it), and pass only the first part to our `loadTenant()` method. We're not passing the whole hostname for many reasons, but mostly because it leaves us open to change domains or use this for other things in the future.\r\n\r\nNext we're going to edit `TenantManager::loadTenant()` to perform the identification.\r\n\r\n```php\r\npublic function loadTenant(string $identifier): bool {\r\n    $tenant = Tenant::query()->where('subdomain', '=', $identifier)->first();\r\n    \r\n    if ($tenant) {\r\n        $this->setTenant($tenant);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n```\r\n\r\nAs you can see, this is identical to the domain identification, except we are using a different column. Like with the `domain` column, I'm assuming this is a unique column that contains only the tenant 'slug'.\r\n\r\nAnd that's it for subdomain identification. Marginally more complex than domain identification.\r\n\r\n### BONUS: Subdomain OR Domain identification\r\nIt's entirely possible that you're providing subdomains for all tenants, but domains for those that pay for a higher package (or those that you like). You can modify both of the above options to allow for this.\r\n\r\nWe're going to create the env variable as mentioned in subdomain identification, then we're going to merge both pieces of code for the middleware.\r\n\r\n```php\r\npublic function handle($request, Closure $next)\r\n{\r\n    $host = $request->getHost();\r\n    $pos = strpos($host, env('TENANT_DOMAIN'));\r\n    \r\n    if ($this->tenantManager->loadTenant($pos !== false ? substr($host, 0, $pos - 1) : $host, $pos !== false)) {\r\n        return $next($request);\r\n    }\r\n    \r\n    throw new NotFoundHttpException;\r\n}\r\n```\r\n\r\nThe biggest difference here is that we remove the `$pos` check from the if, because there may be no subdomain. We replace our `loadTenant` argument with a ternary if that passes the 'slug' if present, or the whole host. We're also passing in another argument which is a boolean representing whether or not this is a subdomain.\r\n\r\nNow we can't make some minor amendments to our `TenantManager::loadTenant()` method.\r\n\r\n```php\r\npublic function loadTenant(string $identifier, bool $subdomain): bool {\r\n    $tenant = Tenant::query()->where(subdomain ? 'subdomain' : 'domain', '=', $identifier)->first();\r\n    \r\n    if ($tenant) {\r\n        $this->setTenant($tenant);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n```\r\n\r\nWe've add in support for the second argument, as well as another ternary if statement to change the column name we query against.\r\n\r\nThis is just the basic identification and doesn't include any logic about whether or not a tenant can have domain. Even though that is unfortunately outside the scope of this article, and that I'd never condone the adding of methods to the eloquent model (because it's already bloated), the following is a quick example of how you'd modify your `TenantManager::loadTenant()` method to achieve this.\r\n\r\n```php\r\nif ($tenant) {\r\n    if (! $subdomain && !$tenant->canHaveDomain()) {\r\n        throw new NotFoundHttpException;\r\n    }\r\n    $this->setTenant($tenant);\r\n    return true;\r\n}\r\n```\r\n\r\n### Path Identification\r\nPath identification would be identifying the tenant based on a part of the URL path, specifically the first section after the domain. An example of this would be `http://myawesome.app/ollieread`, where `ollieread` is the tenant identifier.\r\n\r\nFor this example, we're actually going to make use of Laravels route parameters, and a little known route instance method that allows us to remove the parameter once it has been processed, so that we don't need to expect it on our controllers. Our tenant route group is going to be slightly different to the one up the top.\r\n\r\n```php\r\nRoute::group([\r\n    'prefix'     => '/{tenant}',\r\n    'middleware' => \\App\\Http\\Middleware\\IdentifyTenant::class,\r\n    'as'         => 'tenant:',\r\n], function () {\r\n    // Tenant routes here\r\n});\r\n```\r\n\r\nAll we've done is add a prefix using a route variable `tenant`. Now we can modify our `IdentifyTenant::handle()` method.\r\n\r\n```php\r\npublic function handle($request, Closure $next)\r\n{    \r\n    if ($this->tenantManager->loadTenant($request->route('tenant'))) {\r\n        $request->route()->forgetParameter('tenant');\r\n        return $next($request);\r\n    }\r\n    \r\n    throw new NotFoundHttpException;\r\n}\r\n```\r\n\r\nYour instance of Laravels `Request` object will, if for a matching route, contain an instance of `Route` that allows us to access the parameters like you see above. Here we're assuming that all of the URLs must be prefixed with `/{tenant}` so we throw a 404 if no tenant was found. If the tenant was found, we remove the parameter (we don't need it again), and continue down the chain of middleware.\r\n\r\nIf you plan to support other none tenant specific pages that are also accessible, you'll want to make sure that your tenant route group is defined _AFTER_ all of the others.\r\n\r\nLets modify our `TenantManager::loadTenant()` method.\r\n\r\n```php\r\npublic function loadTenant(string $identifier): bool {\r\n    $tenant = Tenant::query()->where('slug', '=', $identifier)->first();\r\n    \r\n    if ($tenant) {\r\n        $this->setTenant($tenant);\r\n        return true;\r\n    }\r\n    \r\n    return false;\r\n}\r\n```\r\n\r\nLike in all of the other examples, I'm assuming that `slug` is a unique column containing the tenants specific identifier.\r\n\r\nThere we go, domain, subdomain and path tenant identification, with a bonus subdomain and domain example thrown in.\r\n\r\n# How do I generate tenant routes?\r\nAhh, this is something that's quite easily overlooked. Since in all of the examples above the URL requires a specific piece of identifying information, your routes just simply won't work properly. In the case of the path identification, it won't even be able to find the routes as there will be a missing parameter.\r\n\r\nWhile I'm going to regret suggesting adding a method to your `App\\Tenant` model, it's the simplest example. So open up your model and add the following method;\r\n\r\n```php\r\npublic function route($name, $parameters = [], $absolute = true) {\r\n    return app('url')->route($name, $parameters, $absolute);\r\n}\r\n```\r\n\r\nThis is a 1:1 copy of the `route()` helper method, so that you can do things like `$tenant->route('home.index')` or whatever you please. Now, depending on the method of identification that you're using, there are some changes we need to make to this method.\r\n\r\n### Domain & Subdomain Identification\r\nFor domain and subdomain identification, either supporting both or only one, we're going to do the following;\r\n\r\n**Domain**\r\n\r\n```php\r\npublic function route($name, $parameters = []) {\r\n    return 'https://' . $this->domain . app('url')->route($name, $parameters, false);\r\n}\r\n```\r\n\r\n**Subdomain**\r\n\r\n```php\r\npublic function route($name, $parameters = []) {\r\n    return 'https://' . $this->subdomain . app('url')->route($name, $parameters, false);\r\n}\r\n```\r\n\r\n**Both**\r\n\r\n```php\r\npublic function route($name, $parameters = []) {\r\n    $host = $this->domain ?? $this->subdomain;\r\n    return 'https://' . $host . app('url')->route($name, $parameters, false);\r\n}\r\n```\r\n\r\nWe're removing the third argument from the method and passing `false` in its place to the real `route()` method. The reason for this is that when that is `true`, it will prefix the returned route with the URL, which we're doing manually. I'm using `https://` because everything should be `https://` but the choice is yours.\r\n\r\n### Path Identification\r\nPath identification is different, yet still as simple. All we need to do is add the tenant path to the start of the arguments.\r\n\r\n```php\r\npublic function route($name, $parameters = [], $absolute = true) {\r\n    return app('url')->route($name, array_merge([$this->slug], $parameters), $absolute);\r\n}\r\n```\r\n\r\nThere we go. Since our little array containing the tenant slug/path is numerically keyed (automatically), it'll be at the start of the resulting array, whether `$parameters` is numerically keyed or not.\r\n\r\n# Handling tenant data\r\nBy now you've probably encountered two groups of people, polarised by this particular part of multi-tenancy. On one hand you have those that demand that you use a single database for your tenant data (Database as in `CREATE DATABASE`), while their rivals, demand that you use the multi-database approach.\r\n\r\nIn reality it's not as clear cut as that. I'm a rather large proponent of the multi-database approach, but that's primarily because it made sense with what I was building. In fact recently, while working on my [WorldBuilder Online](https://worldbuilder.online) project, I came to realise that the requirements had shifted so much, that my multi-database approach was no longer viable and I had to go back to the drawing board on that one.\r\n\r\nWhile you can't entirely avoid having to refactor weeks worth of code, you can help reduce to possibility of doing so, by thinking about it ahead of time, because ultimately, the approach depends entirely on what your system is doing. Generally speaking, I find it boils down to a couple of reasons, so like the choice between multi-tenancy and multi-instance, I've come up with the basic examples below.\r\n\r\n**Use Multi-Database if...** You require the added security of each tenants data being entirely separate. This will allow you to implement a few extra security measures with ease, such as public key encryption. You should also use multi-database if you're using a NoSQL solution (such as MongoDB) and are creating very complex and independent collections/table.\r\n\r\n**Use Single-Database if...** Your users are not tenant specific, you have global community features that tie the tenants together, or the data you're storing isn't that complex or in need of higher security.\r\n\r\nWhichever way you go, I've written the below to help you implement it inside your Laravel codebase.\r\n\r\n### Single Database\r\nThe single database approach is arguable more complex than the multi-database approach. The reason for this is that you have to take a lot of extra steps. As with all other examples, I'll be assuming the existence of `App\\Tenant`.\r\n\r\nAny primary model that requires tenant specific data should have a `tenant_id` foreign key that references `id` on your `tenants` table. You can skip the foreign key on any secondary models. By now you're probably wondering what the difference between a primary and a secondary model is? Well wonder no more!\r\n\r\n**A primary model is...** A model that belongs to a tenant, and cannot exist without its parent tenant. If your tenants can create posts, then your `App\\Post` model should have a `tenant_id` foreign key.\r\n\r\n**A secondary model is...** Any model that has ancestors that belong to a tenant. Much like with primary models, this model must only exist with its parent hierarchy. If your users can comment on posts, then you `App\\Posts\\Comment` model doesn't need a foreign key, as you can only ever access those comments with a valid instance of `App\\Post`, which will always belong to a tenant.\r\n\r\nOutside of this you have your other global models which we shall refer to as your tertiary models. This could be things like `App\\Category` if all of your tenant posts must belong to a generic list of categories. These models don't need a foreign key as they're globally available and not tenant specific.\r\n\r\nThe simplest way to automate all of this is with the user of traits and Laravel scopes, specifically the global scopes rather than the query based scopes.\r\n\r\nSo to get started, lets create our global scope. Typically I would create this is `app/Scopes`, but you can create it wherever you like. We'll call it `TenantOwnedScope`.\r\n\r\n```php\r\nnamespace App\\Scopes;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Builder;\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\nuse Illuminate\\Database\\Eloquent\\Scope;\r\nuse App\\Services\\TenantManager;\r\n\r\nclass TenantOwnedScope implements Scope {\r\n    public function apply(Builder $builder, Model $model) {\r\n        $manager = app(TenantManager::class);\r\n        $builder->where('tenant_id', '=', $manager->getTenant()->id);\r\n    }\r\n    \r\n    public function extend(Builder $builder) {\r\n        $this->addWithoutTenancy($builder);\r\n    }\r\n    \r\n    protected function addWithoutTenancy(Builder $builder) {\r\n        $builder->macro('withoutTenancy', function (Builder $builder) {\r\n            return $builder->withoutGlobalScope($this);\r\n        });\r\n    }\r\n}\r\n```\r\n\r\nHere we have our tenant scope, raring and ready to go. The `apply()` method will apply the given scope to the query automatically, it accepts an instance of the builder and the current model. We have our `extend()` method which allows us to add some optional scopes. In this example we add `withoutTenancy()` added by `addWithoutTenancy()` so that you can skip the tenant foreign key and retrieve all rows. This is particularly useful for admin areas where you want to see anything and everything.\r\n\r\nThe reason that we're using a where on the foreign key directly is that bogging everything down with one of Laravels automatically relationship checks is going to be slower, especially if the majority of your models have this scope. The relationship checks (`has()` and `whereHas()`) create subqueries which obviously add to a queries overhead.\r\n\r\nNow, you can add this scope by overriding a models `boot()` method, but we don't want to do that, as we're going to do a little bit more magic.\r\n\r\nWe're going to create ourselves a trait, or a concern as Laravel refers to them. Typically I'd create this in `app/Concerns`, but you can create it wherever you like. We'll call it `OwnedByTenant`.\r\n\r\n```php\r\nnamespace App\\Concerns;\r\n\r\nuse App\\Scopes\\TenantOwnedScope;\r\n\r\ntrait OwnedByTenant {\r\n    public static function bootOwnedByTenant() {\r\n        static::addGlobalScope(new TenantOwnedScope);\r\n    }\r\n    \r\n    public function tenant() {\r\n        $this->belongsTo(Tenant::class, 'tenant_id');\r\n    }\r\n}\r\n```\r\n\r\nOnce we've created this we can add it to any of our primary models like so;\r\n\r\n```php\r\nuse App\\Concerns\\OwnedByTenant;\r\n\r\nclass PrimaryModel extends Model {\r\n    use OwnedByTenant;\r\n}\r\n```\r\n\r\nWe've done it like this because of a nice little feature of Eloquent. Eloquent will, upon the booting of a model, inspect its traits for a `bootTheirName()` method (where `TheirName` is the name of the trait, so that it can boot any additional things, such as scopes. This is how Laravel soft deletes work. This actually automates the adding of our scope, so that you don't have to manually do anything. We've also added a `tenant()` method with automatically provide the belongs to relationship.\r\n\r\nNow, this all works and we can query our primary models and only receive those that belong to the current tenant. But what about inserts? It's all good and well automatically appended where clauses to read, but our writes should have the `tenant_id` automatically populated.\r\n\r\nWe achieve this by making use of model events, specifically the `creating` event. We aren't going to worry about `update`, as providing that you've written your code properly, it'll be impossible for a model to not currently belong to a tenant. \r\n\r\nGo back to your `OwnedByTenant` trait and edit the `bootOwnedByTenant()` method to look like the following;\r\n\r\n```php\r\npublic static function bootOwnedByTenant() {\r\n    static::addGlobalScope(new TenantOwnedScope);\r\n    \r\n    static::creating(function ($model) {\r\n        if (! $model->tenant_id && ! $model->relationLoaded('tenant')) {\r\n            $model->setRelation('tenant', app(TenantManager::class)->getTenant());\r\n        }\r\n        \r\n        return $model;\r\n    }\r\n}\r\n```\r\n\r\nHere we are binding a closure to the creating event. Laravel fires the `creating` event before performing the actual query, so it's the ideal place for this sort of thing. You may be wondering about my usage of `relationLoaded()` and `setRelation()`, but the reason for this is that if we simply did `if (! $model->tenant)` Laravel would generate and run a query to eager load that relationship, adding a completely unnecessary query. The usage of `setRelation()` is because Laravel doesn't entirely like having relationships set using their magic properties. It will also mark the relationship has loaded, preventing Laravel from to retrieve the tenant from the database if the relationship is accessed on this instance.\r\n\r\nThere we have it, a working single database implementation. The only final point of consideration for this approach is validation and unique indexes. You'll find that as you add more tenants, any unique indexes you have in the database will start shouting if multiple tenants add the same thing. A primary case of this would be if a user has an account with multiple tenants, and your users are tenant specific.\r\n\r\nTo get around this, add the parent foreign key to your unique indexes. For primary models it'd be `$table->unique(['tenant_id', 'slug'])` and for secondary models like `App\\Posts\\Comment`, it'd be `$table->unique(['post_id', 'user_id'])`.\r\n\r\nNow you're going to have an issue with any validation rule that queries the database (`unique`, `exists`, etc), unless you define the rules like `Rule::unique('posts', 'slug')->where('tenant_id', app(TenantManager::class)->getTenant()->id)` which is long winded and takes away the automation that we want to gain from all of this. To get around this, we're going to define a method on our `TenantManager` class, that essentially does this for us. So open up your `TenantManager` and add the following methods;\r\n\r\n```php\r\npublic static function unique($table, $column = 'NULL')\r\n{\r\n    return (new Rules\\Unique($table, $column))->where('tenant_id', $this->getTenant()->id);\r\n}\r\n\r\npublic static function exists($table, $column = 'NULL')\r\n{\r\n    return (new Rules\\Exists($table, $column))->where('tenant_id', $this->getTenant()->id);\r\n}\r\n```\r\n\r\nAs you can see, these methods are direct copies of `Illuminate\\Validation\\Rule::unique()` and `Illuminate\\Validation\\Rule::exists()`. I'm only using these two here as they're the most commonly used, but the same method can be applied to any rules. Now when you define your validation rules you can just put `TenantManager::unique()`, but remember not to use this on secondary or tertiary models.\r\n\r\nSo now you have an automated single database approach to multi-tenancy, with database based validation support.\r\n\r\n### Multiple Databases\r\nThe multi-database approach is very simple, with the exception of migrations and the actual creation of the tenant databases. Unlike the single database approach though, we don't have to bother with scopes or traits, because we know that a tenants database will contain only its data, and that's a beautiful thing.\r\n\r\nFirst things first, we want to tell Laravel about our tenant databases by creating a new connection. For simplicity, I'm going to assume that it's on the same database server. \r\n\r\nOpen up `app/config/database.php` and added the following **AFTER** the `mysql` connection. It's important to keep the original, as that's where our `tenants` table will exist, and any other global data.\r\n\r\n```\r\n'tenant' => [\r\n    'driver'      => 'mysql',\r\n    'host'        => env('DB_TENANT_HOST', '127.0.0.1'),\r\n    'port'        => env('DB_TENANT_PORT', '3306'),\r\n    'username'    => env('DB_TENANT_USERNAME', 'forge'),\r\n    'password'    => env('DB_TENANT_PASSWORD', ''),\r\n    'unix_socket' => env('DB_TENANT_SOCKET', ''),\r\n    'database' => '',\r\n    'charset'     => 'utf8mb4',\r\n    'collation'   => 'utf8mb4_unicode_ci',\r\n    'prefix'      => '',\r\n    'strict'      => false,\r\n    'engine'      => null,\r\n],\r\n```\r\n\r\nYou'll notice that here we're referring to some env variables that don't exist yet, so go ahead and define these in both your `.env` and `.env-example` files. Also pay special attention to the fact that we don't have a `database` entry in our config array.\r\n\r\nSo how will Laravel know what the database name is? Well, we're going to go back to our provider (`AppServiceProvider`/`TenantServiceProvider`) and add the following to bottom of the `register()` method.\r\n\r\n```php\r\n$this->app['db']->extend('tenant', function ($config, $name) use ($manager) {\r\n    $tenant = $manager->getTenant();\r\n    \r\n    if ($tenant) {\r\n        $config['database'] = 'tenant_' . $tenant->id;\r\n    }\r\n    \r\n    return $this->app['db.factory']->make($config, $name);\r\n});\r\n```\r\n\r\nSo what we're doing is extending the default Laravel database resolver, and telling it that to create a new connection for our `tenant` connection, we should run this closure. This closure will load the current tenant, and set the database name. In this case I'm using `tenant_{ID}` as the format. We're not throwing an exception if no tenant is set, because there are times when we just want the connection, without a database, which you'll find out about later on.\r\n\r\nTo have our tenant specific models, both primary and secondary know what to do, we're going open them up and add `protected $connection = 'tenant';` to the top of the class.\r\n\r\nNow we have a working multi-database approach to multi-tenancy. Our models know about the tenant specific database, and Laravel knows how to get the correct database. What we don't have however, is a way of creating the database, and a way of running tenant specific migrations.\r\n\r\nCreating migrations the standard way is not going to work, as that's going to end up migrating them on our global database, which we don't want. Create a `tenants` directory within `database/migrations`, and append the `--path` option when creating a migration, like so;\r\n\r\n```\r\nphp artisan make:migration create_posts_table ---path=database/migrations/tenants`\r\n```\r\n\r\nBy default the migrator is going to ignore this directory, so we don't need to worry about it. But how do we run our tenant migrations? To do so, we're going to need to create a command by running the following in the terminal;\r\n\r\n```\r\nphp artisan make:command TenantMigrate\r\n```\r\n\r\nThis will create the file `app/Console/Commands/TenantMigrate.php`, so open it and edit it like so;\r\n\r\n<div class=\"tabs\">\r\n<div class=\"tab__bar\">\r\n<div class=\"tab tab--active\" data-target=\"code-57\">Laravel 5.7</div>\r\n<div class=\"tab\" data-target=\"code-58\">Laravel 5.8</div>\r\n</div>\r\n<div class=\"tab__content tab__content--active\" data-name=\"code-57\">\r\n\r\n```php\r\nnamespace App\\Console\\Commands;\r\n\r\nuse Illuminate\\Console\\Command;\r\nuse App\\Services\\TenantManager;\r\nuse App\\Tenant;\r\n\r\nclass TenantMigrate extends Command {\r\n\r\n    protected $signature = 'tenants:migrate';\r\n    \r\n    protected $description = 'Migrate tenant databases';\r\n    \r\n    protected $tenantManager;\r\n    \r\n    protected $migrator;\r\n    \r\n    public function __construct(TenantManager $tenantManager) {\r\n        parent::__construct();\r\n\r\n        $this->tenantManager = $tenantManager;\r\n        $this->migrator = app('migrator');\r\n    }\r\n    \r\n    public function handle() {\r\n        $tenants = Tenant::all();\r\n\r\n        foreach ($tenants as $tenant) {\r\n            $this->tenantManager->setTenant($tenant);\r\n            \\DB::connection('tenant')->reconnect();\r\n            $this->migrate();\r\n        }\r\n    }\r\n\r\n    private function migrate() {\r\n        $this->prepareDatabase();\r\n        $this->migrator->run(database_path('migrations/tenants'), []);\r\n\r\n        foreach ($this->migrator->getNotes() as $note) {\r\n            $this->output->writeln($note);\r\n        }\r\n    }\r\n\r\n    protected function prepareDatabase() {\r\n        $this->migrator->setConnection('tenant');\r\n\r\n        if (! $this->migrator->repositoryExists()) {\r\n            $this->call('migrate:install');\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n</div>\r\n<div class=\"tab__content\" data-name=\"code-58\">\r\n\r\n```php\r\nnamespace App\\Console\\Commands;\r\n\r\nuse Illuminate\\Console\\Command;\r\nuse App\\Services\\TenantManager;\r\nuse App\\Tenant;\r\n\r\nclass TenantMigrate extends Command {\r\n\r\n    protected $signature = 'tenants:migrate';\r\n    \r\n    protected $description = 'Migrate tenant databases';\r\n    \r\n    protected $tenantManager;\r\n    \r\n    protected $migrator;\r\n    \r\n    public function __construct(TenantManager $tenantManager) {\r\n        parent::__construct();\r\n\r\n        $this->tenantManager = $tenantManager;\r\n        $this->migrator = app('migrator');\r\n    }\r\n    \r\n    public function handle() {\r\n        $tenants = Tenant::all();\r\n\r\n        foreach ($tenants as $tenant) {\r\n            $this->tenantManager->setTenant($tenant);\r\n            \\DB::purge('tenant');\r\n            $this->migrate();\r\n        }\r\n    }\r\n\r\n    private function migrate() {\r\n        $this->prepareDatabase();\r\n        $this->migrator->run(database_path('migrations/tenants'), []);\r\n    }\r\n\r\n    protected function prepareDatabase() {\r\n        $this->migrator->setConnection('tenant');\r\n\r\n        if (! $this->migrator->repositoryExists()) {\r\n            $this->call('migrate:install');\r\n        }\r\n    }\r\n}\r\n```\r\n\r\n</div>\r\n</div>\r\n\r\nThis command is a modified version of the default migration command. The main differences are that we're injecting the tenant manager, and running all tenant migrations for all tenants. The most important bit of this class is the `\\DB::connection('tenant')->reconnect()` call. When we change to the next tenant in the collection, the old connection is going to still exist, so Laravel won't run our closure, so we're run the migrations on the old tenants database.\r\n\r\n:::info\r\nIn Laravel 5.8 and above, `\\DB::connection('tenant')->reconnect()` should be replaced with `\\DB::purge('tenant')`\r\n:::\r\n\r\nThe `prepareDatabase` method will create the standard `migrations` table within the tenant database, meaning that each tenant has a record of the migrations ran. \r\n\r\nNow that we have our command, register it by opening up `app/Console/Kernel.php` and adding `App\\Console\\Commands\\TenantMigrate::class` to the`$commands` property.\r\n\r\nNow, when you want to run your tenant migrations you can run the following;\r\n\r\n```\r\nphp artisan tenants:migrate\r\n```\r\n\r\nYou may wondering why we didn't just use the following;\r\n\r\n```\r\nphp artisan migrate --path=database/migrations/tenants --database=tenant\r\n```\r\n\r\nThe reason, is that that won't cycle through the accounts and update the connection with the tenant database name.\r\n\r\nThe only thing we have left to do, is create the tenant database in the first place. Typically, I've created myself a job called `TenantDatabase`, that runs the query. There are lots of ways of doing this, and lots of views and approaches, but the simplest is this.\r\n\r\nRun the following command;\r\n\r\n```\r\nphp artisan make:job TenantDatabase\r\n```\r\n\r\nThis will create the file `app/Jobs/TenantDatabase.php`, so open it and edit it like so;\r\n\r\n<div class=\"tabs\">\r\n<div class=\"tab__bar\">\r\n<div class=\"tab tab--active\" data-target=\"code-57\">Laravel 5.7</div>\r\n<div class=\"tab\" data-target=\"code-58\">Laravel 5.8</div>\r\n</div>\r\n<div class=\"tab__content tab__content--active\" data-name=\"code-57\">\r\n\r\n```php\r\nnamespace App\\Jobs;\r\n\r\nuse App\\Services\\TenantManager;\r\nuse App\\Tenant;\r\nuse Illuminate\\Bus\\Queueable;\r\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\r\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\r\nuse Illuminate\\Queue\\InteractsWithQueue;\r\n\r\nclass SetupAccountDatabase implements ShouldQueue {\r\n\r\n    use Dispatchable, InteractsWithQueue, Queueable;\r\n\r\n    protected $tenant;\r\n\r\n    protected $tenantManager;\r\n\r\n    public function __construct(Tenant $tenant, TenantManager $tenantManager) {\r\n        $this->tenant        = $tenant;\r\n        $this->tenantManager = $tenantManager;\r\n    }\r\n\r\n    public function handle() {\r\n        $database    = 'tenant_' . $this->tenant->id;\r\n        $connection  = \\DB::connection('tenant');\r\n        $createMysql = $connection->statement('CREATE DATABASE ' . $database);\r\n\r\n        if ($createMysql) {\r\n            $this->tenantManager->setTenant($this->tenant);\r\n            $connection->reconnect();\r\n            $this->migrate();\r\n        } else {\r\n            $connection->statement('DROP DATABASE ' . $database);\r\n        }\r\n    }\r\n\r\n    private function migrate() {\r\n        $migrator = app('migrator');\r\n        $migrator->setConnection('tenant');\r\n\r\n        if (! $migrator->repositoryExists()) {\r\n            $migrator->getRepository()->createRepository();\r\n        }\r\n\r\n        $migrator->run(database_path('migrations/tenants'), []);\r\n    }\r\n}\r\n```\r\n\r\n</div>\r\n<div class=\"tab__content\" data-name=\"code-58\">\r\n\r\n```php\r\nnamespace App\\Jobs;\r\n\r\nuse App\\Services\\TenantManager;\r\nuse App\\Tenant;\r\nuse Illuminate\\Bus\\Queueable;\r\nuse Illuminate\\Contracts\\Queue\\ShouldQueue;\r\nuse Illuminate\\Foundation\\Bus\\Dispatchable;\r\nuse Illuminate\\Queue\\InteractsWithQueue;\r\n\r\nclass SetupAccountDatabase implements ShouldQueue {\r\n\r\n    use Dispatchable, InteractsWithQueue, Queueable;\r\n\r\n    protected $tenant;\r\n\r\n    protected $tenantManager;\r\n\r\n    public function __construct(Tenant $tenant, TenantManager $tenantManager) {\r\n        $this->tenant        = $tenant;\r\n        $this->tenantManager = $tenantManager;\r\n    }\r\n\r\n    public function handle() {\r\n        $database    = 'tenant_' . $this->tenant->id;\r\n        $connection  = \\DB::connection('tenant');\r\n        $createMysql = $connection->statement('CREATE DATABASE ' . $database);\r\n\r\n        if ($createMysql) {\r\n            $this->tenantManager->setTenant($this->tenant);\r\n            \\DB::connection('tenant')->purge();\r\n            $this->migrate();\r\n        } else {\r\n            $connection->statement('DROP DATABASE ' . $database);\r\n        }\r\n    }\r\n\r\n    private function migrate() {\r\n        $migrator = app('migrator');\r\n        $migrator->setConnection('tenant');\r\n\r\n        if (! $migrator->repositoryExists()) {\r\n            $migrator->getRepository()->createRepository();\r\n        }\r\n\r\n        $migrator->run(database_path('migrations/tenants'), []);\r\n    }\r\n}\r\n```\r\n\r\n</div>\r\n</div>\r\n\r\nDon't worry, you don't need to have a queue setup if you don't want one, as this will just run inline when called. I created a job because a command shouldn't be called on the web, which is also why we have the `migrate()` method here. What this class does, is grab the tenant connection, run the statement to create the database, then set the current tenant and reconnect the connection so we're referencing the newly created database, and then run the migration so the database is up to date.\r\n\r\nYou can run the job by calling `App\\Jobs\\TenantDatabase::dispatch($tenant, app(App\\Services\\TenantManager::class))` wherever you need it to be ran.\r\n\r\nSo there you go, a fully functioning multi-database approach to multi-tenancy, that handles the database creation as well as tenant database migrations.\r\n\r\n# What now?\r\nNow you build out your system using the methods above. Have a play with the code I've provided and see if you can improve upon it, or tweak it.\r\n\r\nI'm considering touching on a few follow ups at some point where I cover basic template customisation per tenant, as well as tenant specific storage.\r\n\r\nLet me know in the comments below if there's anything you think I missed, anything you'd like to see, or even to show off something you built by following this.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-08-06 16:30:00",
    "deleted_at": null,
    "created_at": "2018-08-06 11:42:23",
    "updated_at": "2019-10-03 13:46:32"
  },
  {
    "id": 8,
    "series_id": null,
    "category_id": 3,
    "parent_id": null,
    "name": "How I accidentally created an ORM to avoid using Eloquent",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "how-i-accidentally-created-an-orm-to-avoid-using-eloquent",
    "excerpt": "In this article, I'm going to go through some of the reasons I stopped using Eloquent, as well as covering the reason for Articulates creation, and the different iterations that I took to make it what it is today.",
    "content": "Eloquent is a well thought out powerful ORM. It makes the initial steps of any Laravel build easy, but at this point it has become somewhat bloated. \r\n\r\nMany a time I've encountered a wall when I tried to do something with Eloquent that it absolutely didn't like. Sure, it's flexible enough that I can work around, and after some time digging through the masses of functionality and methods that come with every Model, I was able to find what I needed, but it all just felt a bit...dirty.\r\n\r\nAfter a while I noticed that some of my codebases were rife with 'work arounds' (read: hacks) to achieve what I needed while still within the confines of Eloquent. That didn't sit well with me, so I started exploring methods to get away from this way of doing things. Then came...\r\n\r\n# Doctrine\r\nDoctrine again, is a super powerful ORM and while more complex to setup, it can simplify your life. For a while, I swore by Doctrine and used it in place of Eloquent whenever I could. The plus side of Doctrine, much like Eloquent, is that it can do everything. The down side, also like Eloquent, is that it can do everything. Doctrine, as good as it is, is a monolithic ORM that dwarfs Eloquent in comparison.\r\n\r\nWhile Eloquent uses the Active Record pattern, Doctrine uses the Entity Mapper pattern, something that due to my days with Java, I was instantly in love with.\r\n\r\n# Bringing Entities to Eloquent\r\nI didn't want to write my own ORM, because ORMs are complicated and hard. But what if I could bring the approach that I love, to Eloquent?\r\n\r\nThis is actually where Articulate started, hence the name Articulate. It was originally designed to be a wrapper for Eloquent, that let me return entities instead of models. The models were still there, but were treated as query objects that were just used to hydrate my simple data object entities. This worked well, and appeased my need for something different, for a while. After the initial high of working with entities wore off, I realised that the underlying problem was still there, I was still having to add 'work arounds' here and there, and the underlying code was still ugly to look at. The only logical next step, was to remove the models entirely...\r\n\r\n# Stripping out Models\r\nSo all Eloquent models are essentially fancy wrappers for the underlying query builder, and that's cool, because I really like that query builder. However, in removing the models from the equation, I found that I had no way to specify tables, columns or their data types. No way to provide relationship configuration.\r\n\r\nFor a brief time, this didn't bother me. I was happy hard coding that stuff in repositories, because it all seemed..nicer. I'd build my query, run it, then throw the results at an entity manager that would hydrate an entity for me. Slowly I started adding getters and setters that cast and transformed data to the correct types.\r\n\r\nEventually I realised that although simpler than Eloquent models, my entities still had loads of code that they probably didn't have any right to have. So I introduced mappings, Doctrine uses mappings, so I'll go with that...\r\n\r\n# Mapping my Entities\r\nSo I created some mappings, and column/attribute classes to handle the different types. In my mappings you'd provide the table name, the entity class name, and then map each column that you wanted mapping, to a type. An example of one of the earlier mappings is below;\r\n\r\n```php\r\nnamespace Ollieread\\Mappings;\r\n\r\nuse Ollieread\\Articulate\\EntityMapping;\r\nuse Ollieread\\Articulate\\Contracts\\Mapping;\r\nuse Ollieread\\Entities\\Admin;\r\nuse Ollieread\\Repositories\\AdminRepository;\r\n\r\nclass AdminMapping extends EntityMapping\r\n{\r\n    public function entity(): string {\r\n        return Admin::class;\r\n    }\r\n\r\n    public function table(): string {\r\n        return 'admins';\r\n    }\r\n\r\n    public function map(Mapping $mapper) {\r\n        $mapper->setKey('id');\r\n        $mapper->setRepository(AdminRepository::class);\r\n        $mapper->mapInt('id')->setImmutable();\r\n        $mapper->mapString('name');\r\n        $mapper->mapString('email');\r\n        $mapper->mapString('password');\r\n        $mapper->mapString('remember_token');\r\n        $mapper->mapTimestamp('created_at');\r\n        $mapper->mapTimestamp('updated_at');\r\n    }\r\n}\r\n```\r\n\r\nIt's relatively straight forward, you set the attributes for the key, tell it what repository to use and then map all the other attributes you care about.\r\n\r\nAgain, this worked well, I'd use the laravel query builder and then throw the result at an entity manager. The entity manager didn't care where the data came from, just that it was there. I created myself a base repository that had some persistence code in there so I didn't have to write update or insert queries, or manually populate the timestamp attributes. This was all good and well, but checking for the presence and value of the `updated_at` column wasn't a very efficient way of telling whether something should be an update, or insert, since I had entities that didn't have timestamps.\r\n\r\nTo achieve this, I'd need to introduce some sort of basic state to my entities...\r\n\r\n# Introducing Entity States\r\nPersistence state is super simple, just add a boolean flag and a method that checks whether the entity is persisted. But I didn't want to litter my entities with this. So instead, I created a base entity that had this functionality in. I added another method to mark an entity as persisted, and then rolled with it. \r\n\r\nEventually a time came when I only wanted updates to be performed if the entity was dirty. So in goes another state. Super simple, keeps track of which attribute has changed, but that's going to get annoying having to do that in every setter. So I made getters and setters optional, and instead introduced an attributes array to the base entity. It worked quite well, and with a `__get()` and `__set()` implementation I was able to use dynamic properties (which I defined in my docblocks). The base entity would check for a getter so that I could support completely dynamic attributes that didn't exist in my attributes array, and all was well.\r\n\r\nThe only problem now, was that when I hydrated an entity, it was dirty? So in goes a method to clean the dirty state, that would be called after initial hydration.\r\n\r\nI was quite happy with what I had, and I was especially happy with the fact that I had created a data source agnostic system. The only part of my code that knew about the data source, was the repository, and those could be anything. After a while, I realised that the mappings made the code specific to Laravels query builder, or at least, a database....\r\n\r\n# Abstracting Data Sources\r\nMy next step was to abstract out data sources. I created myself an `Illuminate` source that had a builder (overridden Laravel query builder), base repository, source definition, and even its own mapping where you could provide the table name and connection name.\r\n\r\nAlthough only one data source existed, Articulate was finally, a data source agnostic package, or as I like to refer to it, a data source agnostic entity mapper pseudo ORM. Bit of a mouth full, but I like it.\r\n\r\nOff I went to build some projects using my new pseudo ORM, and things were wonderful. My code seemed cleaner, there was a bigger separation between data source and domain objects, and again, life was wonderful. I couldn't however, shake the idea that Articulate couldn't be data source agnostic with only one data source. Fortunately, I had a pet project where I'd been trying to abstract out the way that we interact with REST APIs, since there seemed to be no standard. So I created Respite (you can [read about it here](https://ollieread.com/blog/2018/07/19/treating-apis-like-any-other-data-source)), a package that provided a fluent builder to build up API requests for RESTful APIs. I decided to go a step further and introduce a Respite source into Articulate, because as far as I was concerned, it'd be super cool to treat APIs like they're just a database!\r\n\r\nIt was at this point, having introduced a second data source support, and made Articulate truly data source agnostic in my mind, that I realised what I had done. I had, for all intents and purposes, built an ORM. Truly, I had accidentally built an entire ORM. Sure, it's far simpler than Doctrine, and quite different to Eloquent. There may be certain parts that you'd expect to be there that aren't, but it's flexible. It's easily customisable. And you know what? I love it!\r\n\r\n# Accepting my Fate\r\nWith the realisation that I had in fact, created an ORM, I decided to just go full hog and treat it as such, introducing the following;\r\n\r\n### Components\r\nComponents are objects that encapsulate one or more columns. A primary example of this would be an `Address` component that contains the following attributes;\r\n\r\n- `address_1`\r\n- `address_2`\r\n- `address_3`\r\n- `address_city`\r\n- `address_county`\r\n- `address_country`\r\n- `address_postcode`\r\n\r\nIn this case I can pass my address component anywhere that needs an address, so I can create more flexible code, and rather than different implementations for different address sources, I can have one implementation.\r\n\r\nOn top of that, it means that I don't have to map those attributes on each entity. Instead I can create one global component mapping, meaning that I just add;\r\n\r\n```php\r\n$mapping->component('address', Address::class)\r\n```\r\n\r\nAnd there we go, my entity has inherited the mapping, so instead of `$entity->address_line_1` I can just do `$entity->address->line_1`. It will also work for writes, providing that the component isn't immutable (value object).\r\n\r\n### Multiple Inheritance \r\nWhile similar to the feature of Doctrine with the same name, it's slightly different. It's closer to single table inheritance, but since it doesn't care about tables, it's about the entities. \r\n\r\nA good example of this is the [discord api](https://github.com/ollieread/discord-api) package I've been working on which utilises Articulates Respite source. The discord API will return channels, but a channel can be a DM, text channel or voice channel. There is an attribute that specifies the type, and with each type, there are different sets of attributes. So I define this in my mapping like so;\r\n\r\n```php\r\n$mapping\r\n    ->setChildClasses(Channel\\Text::class, Channel\\DM::class, Channel\\Voice::class, Channel\\Category::class)\r\n    ->setMultipleInheritance(function (array $data) {\r\n        switch ((int)$data['type']) {\r\n            case self::TEXT:\r\n                return Channel\\Text::class;\r\n            case self::DM:\r\n                return Channel\\DM::class;\r\n            case self::VOICE:\r\n                return Channel\\Voice::class;\r\n            case self::GROUP_DM:\r\n                return Channel\\DM::class;\r\n            case self::CATEGORY:\r\n                return Channel\\Category::class;\r\n        }\r\n        return Channel::class;\r\n    });\r\n$mapping->snowflake('id')\r\n    ->setImmutable();\r\n$mapping->int('type')\r\n    ->setImmutable();\r\n$mapping->snowflake('guild_id')\r\n    ->for(Channel\\Voice::class, Channel\\Text::class, Channel\\Category::class);\r\n$mapping->int('position')\r\n    ->for(Channel\\Voice::class, Channel\\Text::class, Channel\\Category::class);\r\n$mapping->entity('permission_overwrites', Channel\\Overwrite::class, true)\r\n    ->belongsTo(Channel\\Voice::class, Channel\\Text::class);\r\n$mapping->string('name');\r\n$mapping->string('topic')\r\n    ->for(Channel\\Text::class);\r\n$mapping->bool('nsfw')\r\n    ->for(Channel\\Voice::class, Channel\\Text::class);\r\n$mapping->snowflake('last_message_id')\r\n    ->for(Channel\\Text::class, Channel\\DM::class);\r\n$mapping->int('bitrate')\r\n    ->for(Channel\\Voice::class);\r\n$mapping->int('user_limit')\r\n    ->for(Channel\\Voice::class);\r\n$mapping->array('recipients')\r\n    ->for(Channel\\DM::class);\r\n$mapping->string('icon');\r\n$mapping->snowflake('owner_id')\r\n    ->for(Channel\\DM::class);\r\n$mapping->snowflake('application_id');\r\n$mapping->snowflake('parent_id')\r\n    ->for(Channel\\Voice::class, Channel\\Text::class, Channel\\Category::class);\r\n$mapping->timestamp('last_pin_timestamp', 'c')\r\n    ->setImmutable()\r\n    ->for(Channel\\Text::class);\r\n```\r\n\r\n### Relationships\r\nA core part of any ORM is relationships. I'm currently working on an implementation of this, but in a simpler way than Laravel. Since you can already specify entity attributes, like in the example above, I simply add a `setResolver()` method to entity attributes, that takes an instance of `Sprocketbox\\Articulate\\Contracts\\Resolver` or `\\Closure`.\r\n\r\nIt's still a WIP, and I've added a few Illuminate specific resolvers, but my local code looks like this for the entity definition;\r\n\r\n```php\r\n$mapping->entity('user', User::class)\r\n        ->setResolver(new BelongsTo('user_id', 'id'))\r\n        ->setColumnName('user_id');\r\n```\r\n\r\nSo when querying the entity that this mapping is for (`Assignments`) I can simply add `$query->with('user')` and it'll use the resolver to load and populate the user.\r\n\r\nThe wonderful side effect of this particular piece of functionality, is that it will work across data sources. I could have `$query->with('stripe_customer')` in my query, and after retrieving my user from the database, it'd call the Stripe API, retrieve the customer data, build it into a previously define entity, and inject it. How marvelous!\r\n\r\n# Should I use Articulate?\r\nIf you want to. I enjoy it far more than Eloquent, and I find that it keeps my codebase tidier, but it's not everyones cup of tea. It's primary reason for existence is that some of the things I was working on required some quite complex queries, along with some complex functionality, so I was trying to find a way to make the codebase less daunting.\r\n\r\nIf you want to use Articulate, you can find it [here](https://github.com/sprocketbox/articulate) and you can find WIP documentation [here](https://sprocketbox.github.io/articulate).\r\n\r\n\r\nI'm interested in hearing your thoughts on the package, whether you've used it or would consider it, or even your thoughts on Eloquent.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-08-07 17:35:25",
    "deleted_at": null,
    "created_at": "2018-08-07 18:35:25",
    "updated_at": "2018-08-07 18:47:41"
  },
  {
    "id": 11,
    "series_id": null,
    "category_id": 1,
    "parent_id": null,
    "name": "Laravel RBAC (role based access control), without over-engineering",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "laravel-rbac-role-based-access-control-without-over-engineering",
    "excerpt": "My one-man quest to stop people over-engineering their code continues, but this time I'll be approaching roles & permissions, commonly referred to as an RBAC.",
    "content": "Access control is everywhere you look. GitHub, BitBucket, Slack, Atlassian, DigitalOcean, and many many more employ the usage of access control to...well...control access.\r\n\r\nDoes your project have need of multiple levels of admin, or does it support teams whereby users can invite other users to share access/contribute? Perhaps you have a discussion board/forum and you want certain users to administer, while others only moderate or contribute. If that's the case, then you'll want to implement some type of access control. The most common terms used to refer to this kind of functionality, is that of roles & permissions or RBAC.\r\n\r\nMuch like anything else, everyone and their dog has a Laravel package out there providing roles & permissions, and they're over-engineered or over-complicated. I know this is the second article I've written in as many weeks regarding the over-engineering of features, but it really is an issue. If something is over-engineered or over-complicated it's quite difficult to figure out what exactly is happening, and more often than not, you're not going to have the time to dedicate to figuring out what the developers are doing, so you just end up using the package blindly.\r\n\r\nDo you really want to trust code that you don't know, to control something as sensitive as the access that users have to your content? It's a rhetorical question, the answer is no. If you answered yes, you're wrong.\r\n\r\nIn this article I'm going to run down how to implement a relatively simple, yet flexible and powerful RBAC with Laravel, as well as explaining it as we go.\r\n\r\n# What exactly is an RBAC?\r\nRBAC stands for role based access control and is more than likely what you actually think of when you hear the term ACL. I myself have fallen foul of this as I wrote an article back in 2016 about writing a simplified ACL with Laravel. What I wrote, was an RBAC, and that article is essentially the ancestor of this one.\r\n\r\nTo quote the [RBAC](https://en.wikipedia.org/wiki/Role-based_access_control) Wikipedia entry;\r\n\r\n> Role-based-access-control (RBAC) is a policy neutral access control mechanism defined around roles and privileges. The components of RBAC such as role-permissions, user-role and role-role relationships make it simple to perform user assignments.\r\n\r\nAs you'll see from the above, this falls more inline with our role and permission setup. The idea is that a user, or a given authenticated entity is assigned one or more roles. Each of those roles will have a set of permissions which directly correlate to actions within the system, or at least, represent them. It's rare that we care whether or not a user has a particular role as they're essentially just a way to group permissions.\r\n\r\n### But what about ACL?\r\nThe terms ACL and RBAC are commonly mixed up, and while the definitions are theoretically interchangeable, they're technically quite different. The Wikipedia entry for [ACL](https://en.wikipedia.org/wiki/Access_control_list) says;\r\n\r\n> An access control list (ACL), with respect to a computer file system, is a list of permissions attached to an object. An ACL specifies which users or system processes are granted access to objects, as well as what operations are allowed on given objects.\r\n\r\nWith an ACL you're controlling access to individual objects, or in our case, rows. You could arguably consider Laravels Policies to be a form of ACL, as you check per object/model instance, rather than as a whole on the resource. It's a very loose comparison as Policies are open to interpretation and implementation.\r\n\r\n# Creating an RBAC\r\nCreating role based access control within Laravel is actually quite a simple matter. Much like multi-tenancy, it's one of those things that appears far more complicated than it actually is.\r\n\r\nHere's what we know of RBACs so far;\r\n\r\n- It has users\r\n    - Users have 1 or more roles\r\n- It has roles\r\n    - Roles have permissions\r\n- It has permissions\r\n\r\nThis particular list translates almost directly to Eloquent relationships, so lets start there. We're going to need three models to achieve this, but I'm assuming that you already have a `User` model or some other authenticated model, whether it's an admin or what.\r\n\r\n### Creating our Role model\r\nOur first model to create is a `Role` model, aha role model!\r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Role extends Model {\r\n    protected $table = 'roles';\r\n    protected $fillable = [\r\n        'name', 'ident', 'description', 'active', 'level',\r\n    ];\r\n    protected $casts = [\r\n        'active' => 'bool',\r\n        'level' => 'int',\r\n    ];\r\n}\r\n```\r\n\r\nIt's a straight forward model, though you may be curious about 3 of the fields I've added here. The `ident` field is essentially a sluggified version of the `name` and exists solely in case we do care what role a user has. The `active` field is one I add to almost everything these days, as this allows me to enable or disable a role, and trust me, there are plenty of reasons you'd do this.\r\n\r\nThe last field, `level`, is there to define a loose hierarchy of roles. For example, you may have three different roles with permission to edit users, and without this level control, a user with a lower role could swap out their roles, or even edit users above them in the hierarchy. For the purpose of this article, I'm going to consider `0` to be the highest, because ascending order is simplest.\r\n\r\n### Creating our Permission model\r\nNow that we've got our roles, we need to add permissions. \r\n\r\n```php\r\nnamespace App\\Models;\r\n\r\nuse Illuminate\\Database\\Eloquent\\Model;\r\n\r\nclass Permission extends Model {\r\n    protected $table = 'permissions';\r\n    protected $fillable = [\r\n        'name', 'ident', 'description', 'active',\r\n    ];\r\n    protected $casts = [\r\n        'active' => 'bool',\r\n    ];\r\n}\r\n```\r\n\r\nAgain, relatively straight forward. It's almost identical to the `Role` model, save for the `level` field. I've kept the `active` field because disabling a permission is a brilliant way of quickly disabling features. The feature technically isn't disabled, but no one can get access to it.\r\n\r\nI'd like to talk about the `ident` field for a minute. So, I like to name my permissions in the same way that I name routes, and those follow the pattern `resource[.child-resource].action`. In fact, I have a direct correlation between 90% of my permissions and the route names. The reason I use the dot notation, is that if I were to add the permission `blog.post.index`, my system would add the following extra permissions;\r\n\r\n- `blog.*`\r\n- `blog.post.*`\r\n\r\nThis would allow me to give a particular role blanket permissions for the `blog` namespace or the `blog.post` namespace. I also make sure to add a `*` permission which is essentially a wildcard that's acceptable by any and all. Normally this is assigned to an `admin.super` role that only I have access to.\r\n\r\nOn top of wildcard permissions, I'll also often create other permissions that don't strictly follow the pattern. A good example of this would be `user.email`, whereby only users/admins with this permission can see the email address of a user. With some CMS systems I've built, I've created a `Page` model that has a `structure_edit` and a `has_content` flag, with the former controlling whether or not the slug can be edited, and the latter being whether or not to display the WYSIWYG editor. Now, I don't want to go around editing the database to change these, so I hide the form checkboxes in an if statement that checks for `page.admin`, allowing me to assign an extra layer of granular permissions on top of `page.edit`.\r\n\r\nNow that we have our models, we're going to need to define the relationships between them.\r\n\r\n# Defining the relationships\r\nYour `Role` model is going to need to know that it has permissions. Add the following method to your `Role` model.\r\n\r\n```php\r\npublic function permissions() {\r\n    return $this->belongsToMany(App\\Models\\Permission::class, 'role_permissions', 'role_id', 'permission_id');\r\n}\r\n```\r\n\r\nTo define the inverse, add the following to your `Permission` model.\r\n\r\n```php\r\npublic function roles() {\r\n    return $this->belongsToMany(App\\Models\\Role::class, 'role_permissions', 'permission_id', 'role_id');\r\n}\r\n```\r\n\r\nThis relationship is called a [many to many](https://laravel.com/docs/5.6/eloquent-relationships#many-to-many) relationship, and utilises something called a pivot table. In this case, our pivot table is  called `role_permission` and will simply contain `permission_id` and `role_id` columns.\r\n\r\nNow you need to go to your user model, or whatever your authenticated entity is, and define the relationships. Now, I always go for users having more than 1 role, but you don't have to.\r\n\r\nTo allow for multiple roles, add the following to your model;\r\n\r\n```php\r\npublic function roles() {\r\n    return $this->belongsToMany(App\\Models\\Role::class, 'user_roles', 'user_id', 'role_id');\r\n}\r\n```\r\n\r\nThen on your `Role` model add the inverse;\r\n\r\n```php\r\npublic function users() {\r\n    return $this->belongsToMany(App\\Models\\User::class, 'user_roles', 'role_id', 'user_id');\r\n}\r\n```\r\n\r\nIf you only want users to have 1 role, you can add the following instead to your user model;\r\n\r\n```php\r\npublic function role() {\r\n    return $this->belongsTo(App\\Models\\Role::class, 'role_id');\r\n}\r\n```\r\n\r\nThen the inverse on your `Role` model would be;\r\n\r\n```php\r\npublic function users() {\r\n    return $this->hasMany(App\\Models\\User::class, 'role_id');\r\n}\r\n```\r\n\r\nUnlike all of the other relationships, this is a [one to many](https://laravel.com/docs/5.6/eloquent-relationships#one-to-many) relationship. Your user model will need to contain the foreign key `role_id` to define which role they belong to. Honestly, I don't like this method as it feels too limiting. There's realistically more complexity in only allowing one role than there is allowing for multiple.\r\n\r\n### BONUS: Direct user permissions\r\nIt's entirely plausible to want to assign a particular permission to a user, without creating a separate role or giving them all of the permissions that'd come with being assigned to a role. If you wish to do this, you can have a direct relationship between a user and additional permissions. To do so, add the following to your user model;\r\n\r\n```php\r\npublic function permissions() {\r\n    return $this->belongsToMany(App\\Models\\Permission::class, 'user_permissions', 'user_id', 'permission_id');\r\n}\r\n```\r\n\r\nThen add the inverse to your `Permission` model;\r\n\r\n```php\r\npublic function users() {\r\n    return $this->belongsToMany(App\\Models\\User::class, 'user_permissions', 'permission_id', 'user_id');\r\n}\r\n```\r\n\r\n# Creating our migrations\r\nI'm also assuming here that you're familiar with migrations, so I'll only be giving you the blueprint configuration for the inside of the closure.\r\n\r\n### Creating our Role migration\r\nTo create your role migration, run the following command;\r\n\r\n```bash\r\nphp artisan make:migration create_roles_table\r\n```\r\n\r\nOpen up the `database/migrations/YYYY_MM_DD_HHMMSS_create_roles_table.php` file and add the following to the closure inside the `up()` method.\r\n\r\n```php\r\n$table->increments('id');\r\n$table->string('name');\r\n$table->string('ident')->unique();\r\n$table->text('description');\r\n$table->boolean('active')->default(0); // Default is an int because Laravel will create a TINYINT column\r\n$table->integer('level')->default(99); // Default can be whatever you want really\r\n$table->timestamps();\r\n```\r\n\r\n### Creating our Permission migration\r\nMuch like the role migration, run the following command in your terminal;\r\n\r\n```bash\r\nphp artisan make:migration create_permissions_table\r\n```\r\n\r\nNow open up the `database/migrations/YYYY_MM_DD_HHMMSS_create_permissions_table.php` file and add the following to the closure inside the `up()` method.\r\n\r\n```php\r\n$table->increments('id');\r\n$table->string('name');\r\n$table->string('ident')->unique();\r\n$table->text('description');\r\n$table->boolean('active')->default(0); // Default is an int because Laravel will create a TINYINT column\r\n$table->timestamps();\r\n```\r\n\r\n### Pivot table migrations\r\nNow that we have our migrations for both the `roles` and the `permissions` table we need to add a migration for the pivot tables, `role_permission` and `user_roles`.\r\n\r\nRun the following command;\r\n\r\n```bash\r\nphp artisan make:migration create_role_permissions_table\r\n```\r\n\r\nNow open up the `database/migrations/YYYY_MM_DD_HHMMSS_create_role_permissions_table.php` file and add the following to the closure inside the `up()` method.\r\n\r\n```php\r\n$table->unsignedInteger('role_id');\r\n$table->unsignedInteger('permission_id');\r\n\r\n$table->foreign('role_id')->references('id')->on('roles')->onDelete('cascade');\r\n$table->foreign('permission_id')->references('id')->on('permissions')->onDelete('cascade');\r\n$table->unique(['role_id', 'permission_id']);\r\n```\r\n\r\nWe're adding foreign keys here as we only want valid entries. We're also adding a multi-column unique key so that we don't end up adding permissions to roles more than once.\r\n\r\nIf you opted to have your users capable of holding more than one role, you can repeat the above like so.\r\n\r\nRun the following command;\r\n\r\n```bash\r\nphp artisan make:migration create_user_roles_table\r\n```\r\n\r\nNow open up the `database/migrations/YYYY_MM_DD_HHMMSS_create_user_roles_table.php` file and add the following to the closure inside the `up()` method.\r\n\r\n```php\r\n$table->unsignedInteger('role_id');\r\n$table->unsignedInteger('user_id');\r\n\r\n$table->foreign('role_id')->references('id')->on('roles')->onDelete('cascade');\r\n$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');\r\n$table->unique(['role_id', 'user_id']);\r\n```\r\n\r\nIf instead you want your users to have only one role, you'll need to generate a migration that adds the following;\r\n\r\n```php\r\n$table->unsignedInteger('role_id');\r\n$table->foreign('role_id')->references('id')->on('roles')->onDelete('cascade');\r\n```\r\n\r\nTo run these migrations simply run the `php artisan migrate` command.\r\n\r\n### BONUS: Direct user permission migration\r\nIf you've chosen to allow for users to have specific permissions assigned to them, you're going to need to create that pivot table too, much like we did for `user_roles`.\r\n\r\nRun the following command;\r\n\r\n```bash\r\nphp artisan make:migration create_user_permissions_table\r\n```\r\n\r\nNow open up the `database/migrations/YYYY_MM_DD_HHMMSS_create_user_permissions_table.php` file and add the following to the closure inside the `up()` method.\r\n\r\n```php\r\n$table->unsignedInteger('user_id');\r\n$table->unsignedInteger('permission_id');\r\n\r\n$table->foreign('user_id')->references('id')->on('users')->onDelete('cascade');\r\n$table->foreign('permission_id')->references('id')->on('permissions')->onDelete('cascade');\r\n$table->unique(['user_id', 'permission_id']);\r\n```\r\n\r\nAgain we're adding foreign key relationships, and a multi-column unique key so that we don't assign the same permission to a user multiple times.\r\n\r\n# Implementing our RBAC\r\nLaravel ships with some [authorisation](https://laravel.com/docs/5.6/authorization) functionality, including the policies that I mentioned above. While we don't care about policies, we do care about the [gate](https://laravel.com/docs/5.6/authorization#gates).\r\n\r\nLaravels Gates allow us to define the resolution logic for checking that a user has a given 'gate', which in this case is synonymous for permission. Now, it's highly likely that you're going to be checking more than one permission per request, and while you could pull all permissions down, define gates, and then query for each permission, that's not really ideal. Normally I would actually implement my own version of the `Gate` contract, because it doesn't work for the way that I handle permissions. That's somewhat outside the scope of this article, and to keep things simple I'm going to leave the default one in place.\r\n\r\n### Registering our Permissions\r\nBecause of the way the default `Gate` works, you need to register all of your permissions for it know whether or not a user has them. You may think that we can get away with just registering the specific permissions that a user has, but that isn't the case. Because of the wildcard permissions that we add, the gate needs to know of them all. We'll never actually check for the wildcard permissions directly, but we will definitely use permissions that are covered by them.\r\n\r\nHere you can either use `AppServiceProvider` or create your own provider with `make:provider`. Once you've opened your provider of choice you're going to want to put the following in the boot method;\r\n\r\n```php\r\n$permissions = Permission::pluck('ident');\r\n$permissions->each(function(string $ident) {\r\n    Gate::define($ident, function (User $user) {\r\n        // todo: Add permission checking\r\n    });\r\n```\r\n\r\nWe put this in the boot method because we want to make sure all the other services are registered, services such as the DB and the the auth gates. If you wanted to avoid having to perform a query on every request, you could take this a bit further and cache the results. If you wanted to do this, you could do the following;\r\n\r\n```php\r\n$cacheKey = 'permissions';\r\n$permissions = Cache::get($cacheKey);\r\n\r\nif (! $permissions) {\r\n    $permissions = Permission::pluck('ident');\r\n    Cache::put($cacheKey, $permissions->toArray());\r\n} else {\r\n    $permissions = collect($permissions);\r\n}\r\n\r\n$permissions->each(function(string $ident) {\r\n    Gate::define($ident, function (User $user) {\r\n        // todo: Add permission checking\r\n    });\r\n```\r\n\r\nHere we are checking for the permissions in the cache before hitting the database, and if there are no permissions in the cache, we grab the results from the database and then cache those for future use. Since your actual permissions are unlikely to change frequently it's okay to cache the results. However, if you add a new permission or edit the ident of an existing permission, you'll need to invalidate this cache with `Cache::forget('permissions')`.\r\n\r\n(I'm using `User` here, but that should be whatever your model is)\r\n\r\nYou'll also notice that we've left a todo in there. That's because there is something other stuff we need to do before we can actually check a users permissions.\r\n\r\n### Alternative Permissions\r\nAlternative permissions are the wildcard permissions we've spoken about previously. If you're checking whether or not a user can `blog.post.create`, that should also accept the following;\r\n\r\n- `*`\r\n- `blog.*`\r\n- `blog.post.*`\r\n\r\nTo actually get the alternative permissions we need to build this list up. There are several ways we can go about this, and none of them are pretty. I'm open to suggestions for this, but this is generally how I'd go about it;\r\n\r\n```php\r\n$altPermissions = ['*', $permission];\r\n$permParts = explode('.', $permission);\r\n\r\nif ($permParts && count($permParts) > 1) {\r\n    $currentPermission = '';\r\n    for ($i = 0; $i < (count($permParts) - 1); $i++) {\r\n        $currentPermission .= $permParts[$i] . '.';\r\n        $altPermissions[] = $currentPermission . '*';\r\n    }\r\n}\r\n\r\nreturn $altPermissions;\r\n```\r\n\r\nLet me run through what this is doing. \r\n\r\nI'm assuming that the value of `$permission` is a string, and contains the permission ident we want to get the alternative permissions for. The first thing we do is start building up an array of permissions, and since we can be certain that `*` is accepted here, and the actual permission, we can add those to the array without worrying. Next we're going to [explode](http://php.net/explode) the permission by the `.` character, which essentially splits it by that character and gives us an array containing the parts. If the `.` character is not found, we'll get an array containing the whole permission, which we don't care about as we already have the full permission.\r\n\r\nNext we loop through all of the parts using a for loop. I'm using a for loop here because we want to run through all parts but the last. We build up a `$currentPermission` by just appending the current part, plus `.` to the end, before added that to our array with a `*` on the end. If I were to now call `$permissions = altPermissions('blog.post.create')` I'd get back an array with the following;\r\n\r\n- `*`\r\n- `blog.post.create`\r\n- `blog.post.*`\r\n- `blog.*`\r\n\r\nIn my example there I have the helper function `altPermissions(string $permission): array` so I'll be going with that for the rest of my examples. You should replace this with whatever you're using. You could put this as a method on the `Permission` model, or have it as a helper function somewhere, perhaps even put in your service provider.\r\n\r\nNow we can go back to our todo in `Gate::define()`.\r\n\r\n### Defining our Gates\r\n```php\r\n$permissions->each(function(string $ident) {\r\n    Gate::define($ident, function (User $user) use($ident) {\r\n        $cacheKey = 'user.' . $user->id . '.permissions';\r\n        $userPermissions = Cache::get($cacheKey);\r\n        \r\n        if (! $userPermissions) {\r\n            $userClosure = function ($query) use ($user) {\r\n                $query->where('users.id', '=', $user->id);\r\n            };\r\n\r\n            $userPermissions = Permission::query()\r\n                                     ->whereHas('roles', function ($query) use($userClosure) {\r\n                                         $query->where('active', '=', 1)\r\n                                                      ->whereHas('users', $userClosure);\r\n                                     });\r\n                                     ->orWhereHas('users', $userClosure)\r\n                                     ->groupBy('permissions.id')\r\n                                     ->where('active', '=', 1)\r\n                                     ->pluck('ident');\r\n             Cache::put($cacheKey, $userPermissions->toArray());\r\n         } else {\r\n             $userPermissions = collect($userPermissions);\r\n         }\r\n         \r\n         if ($userPermissions) {\r\n             $altPermissions = altPermissions($ident);\r\n             return null !== $userPermissions->first(function (string $ident) use($altPermissions) {\r\n                 return \\in_array($ident, $altPermissions, true);\r\n             });\r\n         }\r\n         \r\n         return false;\r\n    });\r\n```\r\n\r\nThis has turned into quite a bit of code, so let me break this down for you. \r\n\r\nFirst thing we're doing is setting the `$cacheKey` so that we can use the cached results of a user permissions. The reason for this is that we'll likely be checking for multiple permissions during the course of one single request, and we don't want to query the database every time. \r\n\r\nThe next part of the code goes on to retrieve the values and populate the cache if it isn't set. We're creating a `$userClosure` since the logic for the `roles.users` and `users` `whereHas` are the same, so rather that repeating ourselves we use a variable. What this query actually does, is grab all permissions that are associated with a role, that in turn is associated with the given user, as well as any that are associated directly to the user. We're grouping by `permissions.id` as we don't want repeat permissions, seeing that it's possible that one or more roles could have the same permission, or the user could have a direct permission that's also present in a role. The `pluck('ident')` method, tells it that we don't care about retrieving an instance of `Permission`, we just want the permission `ident`. Oh, and we're also only pulling those that are active, or belong to active roles.\r\n\r\nWe cache the value as an array, because our `pluck()` method returns an instance of `Illuminate\\Support\\Collection`, which is useful, but not for serialising. You'll also see that if we pulled the value from cache, we're transforming that to a collection.\r\n\r\nNext we grab our alternative permissions using the methods we covered earlier, before cycling through the permission idents until we find one that is in our array. Once we do, we return it, whereby we immediately return whether or not the value is null. This will give us a nice boolean return, just like the `return false` we have at the bottom in case any of the above fails.\r\n\r\n# Checking users permissions\r\nNow that we have all the above in place, we can actually check whether or not a given user has the desired permission. We can do this by one several ways.\r\n\r\n### Using Gate\r\nTo use Gate, we can simply do the following;\r\n\r\n```php\r\nif (Gate::allows('blog.post.create')) {\r\n    ...\r\n}\r\n```\r\n\r\nIf you wanted to check for multiple permissions, you can use `check()` to make sure they have all, or `any()` to see if they have at least one;\r\n\r\n```php\r\nif (Gate::check(['blog.post.create', 'blog.post.admin'])) {\r\n    ...\r\n}\r\n```\r\n\r\nAnd\r\n\r\n```php\r\nif (Gate::any(['blog.post.create', 'blog.post.admin'])) {\r\n    ...\r\n}\r\n```\r\n\r\nThere is also a `denies()` method on the gate, that just does the inverse of `allows()` so you can check that a user _DOESN'T_ have the given permission. You can read the [Laravel docs](https://laravel.com/docs/5.6/authorization#authorizing-actions-via-gates) on dealing with Gates if you want to know anything further.\r\n\r\n### Middleware\r\nThe middleware in question does actually use gate, but you don't. See the [docs](https://laravel.com/docs/5.6/authorization#via-middleware) on this. Just add the following to any routes you want protected;\r\n\r\n```php\r\n$route->...->middleware('can:blog.post.create');\r\n```\r\n\r\n### Controllers\r\nIf you're extending the default controller, which you most likely are, you have access to an `authorize()` method that you can use inside your controller actions;\r\n\r\n```php\r\npublic function create() {\r\n    $this->authorize('blog.post.create');\r\n    ...\r\n}\r\n```\r\n\r\nBe aware that this will throw an exception in the form of `Illuminate\\Auth\\Access\\AuthorizationException`. To read more about this, check the [docs](https://laravel.com/docs/5.6/authorization#via-controller-helpers).\r\n\r\n### Your User model\r\nIf you want to be able to check a users permissions directly from an instance of their user model you need to make sure that it implements the `Illuminate\\Contracts\\Auth\\Access\\Authorizable` contract, and uses the `Illuminate\\Foundation\\Auth\\Access\\Authorizable` trait. You'll have to import these classes as aliases since they have the same name and PHP won't let you do that. If you're using the default `User` model, or extending the one that comes with the `Auth` service (`Illuminate\\Foundation\\Auth\\User`) this is already done for you, and you don't need to do anything to your model.\r\n\r\nOnce you have these in places, you can simply do;\r\n\r\n```php\r\n$user->can('blog.create.post');\r\n```\r\n\r\nYou can read more about this in the [docs](https://laravel.com/docs/5.6/authorization#via-the-user-model).\r\n\r\n# Now what?\r\nYou now have a simple yet powerful RBAC for your Laravel application, so get to and create those permissions. Feel free to play around with the code as much as you please. Perhaps you don't like using dot notation? Perhaps you've a better idea about how to build up the alternative permission list? Well give them a go!\r\n\r\nYou'll notice that I haven't added anything about the creation of roles, permissions or their assignments. This is entirely up to you and would depend greatly on how your administration system works. Perhaps in the future I'll follow up with how to implement this with Nova, once it's finally released that is.\r\n\r\nAs always, let me know any feedback or questions you have.\r\n\r\nAs a side note, the comments are being replaced soon, as I've grown somewhat disenchanted with disqus, so I'm going to roll my own :P",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-08-16 00:00:00",
    "deleted_at": null,
    "created_at": "2018-08-17 00:27:39",
    "updated_at": "2018-08-18 20:36:53"
  },
  {
    "id": 13,
    "series_id": null,
    "category_id": 4,
    "parent_id": null,
    "name": "Creating a modern day PHP framework",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "creating-a-modern-day-php-framework",
    "excerpt": "PHP has come a long way since I started development some 15 years ago, and its frameworks are far from the small MVC framework I created back in 2008 to get my head fully around the concept. A lot of frameworks have fallen behind, unable to keep up with the rapidly changing climate, and those that have kept up with it polarise developers. It's easy to bash a framework, but what does it actually take to build a framework? I'm going to give it ago. ",
    "content": "Any of you that frequent this site, or are privy to my public interactions on Twitter, Slack or Reddit, will know that although I'm primarily a Laravel based PHP developer, I have my fair share of issues with the framework. The most common response to my ramblings (read: rants) is;\r\n\r\n> Building a framework is hard, I'd like to see you manage it.\r\n \r\nSo you know what? You're going to.\r\n\r\nThroughout the coming months, maybe even years, I'm going to build out a modern PHP framework called Contraption. I've made a basic start and you can find that and all future code [here](https://github.com/contraption).\r\n\r\n# Why are you building a framework?\r\nSimply put, I am building a framework to see if I can, and if I can, to say that I have. The whole idea is that Contraption is an experiment. I'll be setting myself goals and aims and then working towards those, exploring more about what it actually takes to build a framework. I also figured that it'd be a good subject for a series of articles, detailing problems that I encounter, alternate solutions and my own take on various matters.\r\n\r\n# So what are your goals?\r\nThe goals thus far are quite simple.\r\n\r\n## Keep it simple\r\nWhile my goal isn't to build a 'lightweight framework' like Lumen or Slim, I do intend to keep it as simple as possible, avoiding the over engineering and over complication that inherently comes with an undertaking so massive.\r\n\r\n## PSR compliance\r\nThere are mixed feelings regarding PHP-FIG and their PSRs, but I will be attempting to introduce compliance to all current (and future if they release before I'm finished) PSRs.\r\n\r\n## Make it truly flexible\r\nThere are a lot of frameworks out there that claim to be flexible, but realistically, they're not. Laravel was originally sold as a truly flexible framework, allowing for the swapping out of components, and even using the components in non Laravel codebases. Unfortunately, Laravel has grown to a point where there's not really feasible. The core is rammed full of functionality that few codebases use half of, and each package has many dependencies. \r\n\r\nMy goal with Contraption is to build something that can easily have parts replaced, and those parts can easily be used elsewhere. I'm aware of how difficult this will be to achieve without breaking my first goal, but I'll give it a try.\r\n\r\n## Reinvent all the wheels\r\nIt's no good coming out at the end and being like \"Hey, I built a framework, look how cool it is\" if half of it is just a wrapper for a load of others peoples work. It's not really going to be much of an experiment or challenge if I'm not solving the problems myself. \r\n\r\nIt's also worth noting that during my research into external packages to handle various parts, I was left with a bad taste in my mouth **cough** symfony/http-foundation **cough**, so figured why the hell not, I'll do it myself. There will be certain widely used packages that I won't recreate, flysystem and fast-routes for example.\r\n\r\n## Experiment\r\nMy goal is to have fun, and while it may sound strange that someone is building an entire framework for fun, it's going to be fun none the less. One of the things I plan to do is experiment with different approaches, and just generally introduce bleeding edge features. I already plan to implement [php-ds](https://github.com/php-ds), the PECL extension that introduces several new data-structures to PHP.\r\n\r\n# Will you launch as a proper product?\r\nPossibly. Really it depends what I have when I've finished, and whether anyone will have use for it. It'll most likely end up just being a framework that I use for some personal projects, though only the future will tell.\r\n\r\n# When can we expect articles?\r\nRight now, there's no definitive timeframe for development or writing. It'll be entirely based on getting chance to write code, and then getting chance to write articles about the code. Since I have a baby arriving at some point in the next 6 weeks, my time will be somewhat limited.\r\n\r\nIf you want to see what I have so far, check out the [develop branch](https://github.com/contraption/contraption/tree/develop) on github. At the time of writing this, it just contains a simple 501 line Container implementation.\r\n\r\n# It looks similar to Laravel\r\nIt will do. One of the many things that makes Laravel great, is that for the most part, it uses modern and sensible approaches to problems, meaning that 9 times out of 10, if you're writing some code to achieve a purpose that Laravel does, there will be a decent amount of similarity. While I will be using Laravel as a comparison, I will not just be copying chunks of code. I may borrow approaches if I feel that they are mostly correct, but I'll be slimming them down.\r\n\r\n# Can I contribute?\r\nRight now I'm still in the early days, so I wouldn't really want any code contributions just yet, but if you think it's absolutely necessary, make a PR and I'll take a look. Otherwise, if you want to contribute still, or just don't want to write code, I'm more than welcome to criticism, input, suggestions and just general chit chat regarding this project.\r\n\r\nAmusingly, this is a shorter article than normal, but a far larger subject. If you've any thoughts, suggestions or input in general, let me know below or pop up on [twitter](https://twitter.com/ollieread).",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2018-09-09 00:00:00",
    "deleted_at": null,
    "created_at": "2018-09-09 16:49:49",
    "updated_at": "2018-09-09 17:09:48"
  },
  {
    "id": 14,
    "series_id": null,
    "category_id": 3,
    "parent_id": null,
    "name": "An update on what the future has in store for me and ollieread.com",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "an-update-on-what-the-future-has-in-store-for-me-and-olliereadcom",
    "excerpt": "It has been over a year since I last wrote an article on this site, and my god have things changed since then. Well, I'm back with an update on this site, and a look at what the future has in store.",
    "content": "[[toc]]\r\n\r\nIt has now been just over a year since I last [published an article](https://ollieread.com/articles/creating-a-modern-day-php-framework) to my site. A lot has changed in both my life, and on this site, as you've probably noticed by now.\r\n\r\nThe purpose of this article is to give you a glimpse into the future of ollieread.com, as well as give you some information on what I'm working on, and what I will be working on.\r\n\r\n# What have I been up to?\r\nThe last year of my life has been jam packed, primarily off the back of my daughter being born on the 1st of November 2018. I've been here, just had little time to work on any public content, jumping between client work and being a Dad.\r\n\r\nA few months ago my partner, and baby mama joined my company, [Sprocketbox Ltd](https://sprocketbox.io) as a director, and took on her first solo contract. She's absolutely smashing it.\r\n\r\n## Sprocketbox\r\nOver the past few months I made the decision to move ollieread.com to be a property of Sprocketbox Ltd, my company. The only thing this will change, besides being able to claim the tax back on ollieread.com related purchases, is that all content released by myself whether premium or open source, will be released under the sprocketbox brand. Essentially, packages will be hosted and released by the sprocketbox [github organisation](https://github.com/sprocketbox).\r\n\r\n## The new ollieread.com\r\nYou'll have noticed by now that the site has had a complete overhaul, replacing the old pixelart styled design with a cleaner one. There's still a pixelart me sprite, yes I meant sprite, hover over it.\r\n\r\nThe entire codebase was built from the ground up, all of which is available on [github](https://github.com/ollieread/ollieread.com). The architecture of the new site is very different to the old one, sporting a modular styled approach and utilising actions and operations over controllers and repositories (I'm going to write an article about it).\r\n\r\nWhile the site is still a work in progress, there are 2 notable features. \r\n\r\n### New Comment System\r\nI was previously using Disqus, but I decided to sack that off and write my own. No more JS files injected randomly into the page. The comments support full markdown including [GitHub flavoured markdown](https://github.github.com/gfm/) to help with users trying to debug their code.\r\n\r\n### Topics & Versions\r\nYou'll notice that all articles now have a list of topics and versions (if they have them, admittedly this one doesn't). This allows me to link content to specific topics and specific versions of supporting software. At the time of writing this it doesn't do much besides display, but I'm working on the ability to filter by both of these, allowing you to find content that matches exactly what you need.\r\n\r\n# What am I working on?\r\nBesides client work and this site, I have been working on, and will be working on, a whole bunch of content.\r\n\r\n## Courses\r\nAs you may have seen, I have been working on a course called [Multitenancy with Laravel](https://ollieread.com/articles/multitenancy-with-laravel-a-course-and-package). \r\n\r\nYou may be familiar with the [Kitchen Sink Academy](https://kitchensink.academy), a subscription based course/lesson service that I announced, stupidly, not long before my daughter was born. This is still in the works, and something I'll be jumping straight back into once I've finished Multitenancy with Laravel.\r\n\r\nThese are the only courses I have planned right now, but I definitely want to look into the possibility of creating more in the future.\r\n\r\n## Articles\r\nI have a whole wall of post-it notes listing many topics that I'm going to write about. Many of these planned topics/articles will make use of a new feature I'm working on, called Article Series. This feature will let me break the articles down into smaller articles, linking together under one overarching series, hopefully making it more digestable.\r\n\r\nIn the near future I'll be announcing a release schedule for content, with the aim to publish a new article every X days/weeks/months.\r\n\r\nBelow is a brief look at some of the articles I have planned.\r\n\r\n### Actions & Operations\r\nA writeup on the way I approached this site, dumping the old controller and repository for something akin to command queries, but not as restrictive.\r\n\r\n### APIs with Laravel\r\nA series covering the creation of RESTful APIs with Laravel.\r\n\r\n**Descriptive HTTP Methods** <br /> _Using HTTP methods to more appropriately describe the request._\r\n\r\n**Descriptive HTTP Status Codes** <br /> _Using HTTP status codes to more appropriately describe the response._\r\n\r\n**Utilising HTTP Headers** <br /> _Turbocharging your API by utilising HTTP headers to their fullest potential._\r\n\r\n### Laravel Authorisation\r\nA series exploring all of the different options for authorising users in Laravel.\r\n\r\n**RBACs** <br /> _A look into role based access control and how we can implement it with Laravel. (An update of [my previous article](https://ollieread.com/articles/laravel-rbac-role-based-access-control-without-over-engineering))._\r\n\r\n**ACLs** <br /> _A look into access control lists, specifically Laravels policies, and how we can implement them._\r\n\r\n**Bitwise Permissions** <br /> _A look into how we can store a combination of up to 64 different permissions as a single 64 bit integer. (This site uses bitwise permissions)_\r\n\r\n**Custom Gate** <br /> _Sometimes Laravels default Gate doesn't cut it, lets see what we can do to change that._\r\n  \r\n### Design Patterns \r\nA look into some common design patterns, from a purely PHP approach, including but not limited to:\r\n\r\n  - Pipeline Pattern\r\n  - Builder Pattern\r\n  - Repository Pattern\r\n  - Service Container Pattern\r\n  - Singletons\r\n  - Factory Pattern\r\n  - Proxy Pattern\r\n  - Facades & Service Locator Pattern\r\n\r\n## Packages\r\nI've also got a number of packages in the works, for use on my own projects but also for release.\r\n\r\n### Premium\r\n**Porter** <br />_The multitenancy package._\r\n\r\n**Overseer** <br />_The Nova alternative._\r\n\r\n### Open Source\r\n**Forerunner** <br />_Improved blade components and prototyping tools._\r\n\r\n**Auth+** <br />_An overhaul of Laravels authentication system._\r\n\r\n**Eloquent+** <br />_An extension of Laravel Eloquents functionality._\r\n\r\n**Database+** <br />_Goes hand in hand with Eloquent+._\r\n\r\n**Matter** <br />_The successor to Articulate._\r\n\r\n**Contraption** <br />_A whole bunch of component packages that nicely slot together as a framework._\r\n\r\n# Have something to add?\r\nThe content I write on my site, though partly for me, is mostly for you. If there's something in particular you'd like to see covered, something you'd like addressed, whether it's an idea for a course, article or package, please get in touch. You can reach me on [twitter @ollieread](https://twitter.com/ollieread) or join [the discord](https://discordapp.com/invite/k7yUccq).\r\n\r\nCover image by <a style=\"background-color:black;color:white;text-decoration:none;padding:4px 6px;font-family:-apple-system, BlinkMacSystemFont, &quot;San Francisco&quot;, &quot;Helvetica Neue&quot;, Helvetica, Ubuntu, Roboto, Noto, &quot;Segoe UI&quot;, Arial, sans-serif;font-size:12px;font-weight:bold;line-height:1.2;display:inline-block;border-radius:3px\" href=\"https://unsplash.com/@matt_wojtas?utm_medium=referral&amp;utm_campaign=photographer-credit&amp;utm_content=creditBadge\" target=\"_blank\" rel=\"noopener noreferrer\" title=\"Download free do whatever you want high-resolution photos from Matt Wojtaś\"><span style=\"display:inline-block;padding:2px 3px\"><svg xmlns=\"http://www.w3.org/2000/svg\" style=\"height:12px;width:auto;position:relative;vertical-align:middle;top:-2px;fill:white\" viewBox=\"0 0 32 32\"><title>unsplash-logo</title><path d=\"M10 9V0h12v9H10zm12 5h10v18H0V14h10v9h12v-9z\"></path></svg></span><span style=\"display:inline-block;padding:2px 3px\">Matt Wojtaś</span></a>",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2019-10-03 00:01:00",
    "deleted_at": null,
    "created_at": "2019-10-03 16:32:25",
    "updated_at": "2019-10-06 12:30:08"
  },
  {
    "id": 15,
    "series_id": null,
    "category_id": 3,
    "parent_id": null,
    "name": "Multitenancy With Laravel, a course and package",
    "title": null,
    "heading": null,
    "seo_description": null,
    "slug": "multitenancy-with-laravel-a-course-and-package",
    "excerpt": "Multitenancy with Laravel is a course and package offering that I've been working on for some time. It covers everything you need to do to get started with multitenancy and Laravel.",
    "content": "[[toc]]\r\n\r\n# Introduction\r\n\r\nIn August 2018 I wrote an article titled [Laravel multi-tenancy, avoiding over engineering](https://ollieread.com/articles/laravel-multi-tenancy-avoiding-over-engineering), which was very well received, and still to this date, over 2 years later, is responsible for 25% of my sites traffic.\r\n\r\nIn the time since writing the article I have learned a lot more about multitenancy, both in theory, and in implementation specifically in regards to Laravel. As the topic seemed to be coming up more and more I decided to start putting all of this together. \r\n\r\nAfter some consideration I decided to create both a premium course, called [Multitenancy with Laravel](https://multitenancy.dev), and a premium package, called Porter.\r\n\r\nWhy premium you ask? The plans for both the package featureset and the course content were mammoth, and would take a considerable amount of time to line up, record, edit and build, so the decision was made to sell these, to help cover the time that had been/will be spent making them. Another huge factor in this was that the money from both the course and the package will go back into my company, not just covering me for the time spent, but covering my wages in the future, allowing me to write and record free content.\r\n\r\nThe price of both the course and the package are £99, something that I spent a great deal of time trying to work out. The idea is that it's not too low as to not do the content justice, but not too high so that people are priced out.\r\n\r\nThere's a bit more information below, but you can find out more at [https://multitenancy.dev].\r\n\r\n# The Course\r\nThe course itself covers a large amount of topics, all broken down into small chunks. As well as covering each topic, it also covers all of the options for each topic. \r\n\r\nThe whole course is broken down into chapters, with each chapter having an introduction video that focuses on theory, the options available for this particular chapter, and examples of when and why you'd pick each option. Each option is then broken up into its own video where I write the code and show you how to implement it.\r\n\r\nThe whole aim is to build a simple and clean multitenancy implementation tailored to your needs. One of the core goals for me when planning this course, was for the code that I show you to be as seamless as possible. Once you've written the initial implementation you shouldn't need to do things the 'multitenancy way', it should just work, with minimal adjustments.\r\n\r\nThere is no date set for the release of the course yet, but I'm working on it as much as I can.\r\n\r\n# The Package\r\nThe package, Porter, is by far one of my favourite things that I have ever created (in code). Porter is designed to be an implementation of the course, covering all of the same topics and providing all of the same options and features, but is targetted at people that do not have the time, or the inclination to watch the course and then write your own.\r\n\r\nIt is written to be as seamless as possible, as much like the code in the course, you don't want to be writing things the 'multitenancy way'. Since the package covers 99% of the things that the course covers, there is some initial setup and configuration which can be tricky. Because of this, there's an interactive setup command that you can run, to generate some abstract models and other classes, implementing the correct interfaces and creating the ideal configuration file.\r\n\r\nThough aimed at those of you that don't have the time to complete the course, there's a third purchase option of £148.50 which gives you the package, and the course at 50% off. The reason behind this is that I'm a firm believer in the importance of understanding what you're using, and the course perfectly compliments the package.\r\n\r\nWhile not currently finished, I am very proud of my work on this and can't wait for it to be released. There is no date set for the release of the package, but it will be inline with the course.\r\n\r\n# What does this mean?\r\nI will still continue to write content on here, and I plan to record some free content on a number of topics. The idea behind creating premium courses and packages is that it affords me more time to work on free content.\r\n\r\nSuggestions and feedback as always are welcome, you can reach me on twitter [@ollieread](https://twitter.com/ollieread), or on my [discord](https://ollieread.com/out?url=https%3A%2F%2Fdiscordapp.com%2Finvite%2Fk7yUccq).",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2019-10-03 00:00:00",
    "deleted_at": null,
    "created_at": "2019-10-03 21:48:26",
    "updated_at": "2019-10-06 12:31:28"
  },
  {
    "id": 16,
    "series_id": null,
    "category_id": 2,
    "parent_id": null,
    "name": "The Action and Operation approach",
    "title": "Actions and Operations over Controllers and Repositories",
    "heading": null,
    "seo_description": null,
    "slug": "the-action-and-operation-approach",
    "excerpt": "For a long time, I followed the approach of creating controllers and repositories for individual entities (models). While this approach works, it slowly started to leave a bad taste in my mouth. After much researching into alternative approaches I was unable to find something that truly fit what I wanted. So I decided to have a go at creating my own.",
    "content": "The action and operation approach is one that I recently came up with while trying to solve my never-ending quest for the tidiest code. I imagine that I am not the first person to come up with this solution, and there very well may be some obscure design pattern out there, but I couldn't find it.\r\n\r\nThis article is to serve as a write up about the pattern, and how I came to discover it. \r\n\r\n:::info\r\nRather than constantly writing `Action and Operation`, I'll be referring to it as `A&O`, or simply `The pattern` for the duration of this article.\r\n:::\r\n\r\n[[toc]]\r\n\r\n# Introduction\r\nThe pattern is intended as an alternative to the standard controller and repository approach, by creating code more specific to its purpose. You end up creating more files, but overall it's easier to navigate. \r\n\r\nBut before we can really get into the nitty gritty we need to define what exactly actions and operations are.\r\n\r\n## Actions\r\nActions are essentially more streamlined controllers with a single purpose. They're pretty simple and nothing special, in fact, you're probably already familiar with the idea of 'single action controllers', which isn’t a million miles away from these kind of actions.\r\n\r\nWith the A&O approach an action is the specific end-goal of the routes, so you'd have a single action with a `create` and `store` method. The reason for this is that the `create` method only exists to provide a form to submit data to the `store` method. They're two sides to the same coin.\r\n\r\n### Example Action\r\nIf you want to see an example, check out the [action](https://github.com/ollieread/ollieread.com/blob/master/app/Articles/Actions/Article.php) that handles this page. Feel free to browse around and look at the others.\r\n\r\n## Operations\r\nOperations are a little more complex than actions, but not hugely. The idea behind them is that they represent a particular operation within your system, including all of the ways that operation can be performed. \r\n\r\nOperations in essence are fluent builders, allowing you to daisy-chain a series of setters before calling a `perform` method, that will return the result. \r\n\r\n### Example Operation\r\nExample operations would be `CreateArticle`, `GetArticle` and `GetArticles`, all of which are reused. These particular examples are operations this site uses, with `GetArticles` being used on the [articles](/articles), [version](/articles/version/laravel-6.x), [category](/articles/category/tutorials) and [topic](/articles/topic/laravel) pages.\r\n\r\nIf you want to see the example, check out the [operation](https://github.com/ollieread/ollieread.com/blob/master/app/Articles/Operations/GetArticle.php) on GitHub.\r\n\r\n# Comparison\r\nNow that I've defined actions and operations, let’s look at how they stack up against other approaches.\r\n\r\n:::info\r\nAll of the examples here are based on a standard non-api project build, and the number of actions required for each example would be less if creating an API.\r\n:::\r\n\r\n## Actions vs Controllers\r\nTo compare the two, let’s take a look at the following example Laravel controller.\r\n\r\n```php\r\nnamespace App\\Http\\Controllers;\r\n\r\nclass ArticleController extends Controller {\r\n    public function index() { // ... }\r\n    public function view() { // ... }\r\n    public function create() { // ... }\r\n    public function store() { // ... }\r\n    public function edit() { // ... }\r\n    public function update() { // ... }\r\n    public function delete() { // ... }\r\n    public function destroy() { // ... }\r\n}\r\n```\r\n\r\nEach method represents an endpoint or route, and with the exception of `view` and `index` they're paired up. These sort of controllers can grow quickly requiring a lot of abstraction, typically repositories, which can make navigating a codebase confusing.\r\n\r\nNow, if we were to take this controller and create actions for it, we'd create the following:\r\n\r\n- `Articles\\Index` - An invokable class with a single `__invoke` method that handles the article listing.\r\n- `Articles\\View` - An invokable class with a single `__invoke` method that handles viewing a particular article.\r\n- `Articles\\Create` - Essentially a smaller controller containing only the `create` and `store` methods.\r\n- `Articles\\Edit` - Similar to `Create` but with the `edit` and `update` methods.\r\n- `Articles\\Delete` - The same again but with `delete` and `destroy`.\r\n\r\nWe’ve taken the controller and broken the methods up, abstracting them out into a class that represents their action. We have a few more classes here, but we can immediately identify the class responsible for a particular action, and because of the logical grouping, we know everything in `Articles\\Create` is relevant to the creation of articles.\r\n\r\nYou’ll also notice that I defined two types of actions above, both of which are easy to register with Laravels router.\r\n\r\n```php\r\n$router->get('/articles', Article\\Index::class);\r\n$router->get('/create', [Article\\Create::class, 'create']);\r\n$router->post('/create', [Article\\Create::class, 'store']);\r\n```\r\n\r\n## Actions vs Single Action Controllers\r\nSingle action controllers, if you aren’t familiar, are simple classes with an `__invoke` method. Following on from the above example, the single action controller approach would require the creation of 8 separate classes.\r\n\r\n- `Articles\\Index` - An invokable class with a single `__invoke` method that handles the article listing.\r\n- `Articles\\View` - An invokable class with a single `__invoke` method that handles viewing a particular article.\r\n- `Articles\\Create` - An invokable class with a single `__invoke` method that handles the displaying of the create article form.\r\n- `Articles\\Store` - An invokable class with a single `__invoke` method that handles the processing of the create article form.\r\n- `Articles\\Edit` - An invokable class with a single `__invoke` method that handles the displaying of the edit article form.\r\n- `Articles\\Update` - An invokable class with a single `__invoke` method that handles the processing of the edit article form.\r\n- `Articles\\Delete` - An invokable class with a single `__invoke` method that handles the displaying of the delete article confirmation page.\r\n- `Articles\\Destroy` - An invokable class with a single `__invoke` method that handles the confirmation of the article deletion.\r\n\r\nWhile that is only 3 more than we would create using my action definition, we’ve also made it harder to follow, as the classes responsible for creating an article are actually split across two classes. Chances are, we’re going to be jumping between the two when doing work, to make sure changes are present in both.\r\n\r\nThe benefit of my approach to actions here is the readability of the code and the logical grouping.\r\n\r\n## Action Conclusion\r\nThe pros of using my proposed approach are:\r\n\r\n- Makes the code more readable.\r\n- Helps prevent the creation of huge controllers.\r\n- Groups methods/routes logically.\r\n- Follows the single responsibility principal to a sensible level.\r\n\r\nAnd the cons of using my proposed approach are:\r\n\r\n- Requires more classes than using a single resource controller.\r\n- Actions that can be performed ona resource are split across multiple classes.\r\n\r\nSince the number of classes isn’t an issue on modern systems or using modern editors, and it’s a general rule to avoid creating huge mammoth classes, I think it’s fair to say that the pros vastly outweigh the cons.\r\n\r\n## Operations vs Inline\r\nWhether you're using operations or not, performing things like querying the database inline is less than ideal, especially if it's a process that repeats itself with little to no changes.\r\n\r\nAs I mentioned previously, the `GetArticles` operation for this site is used on 4 public pages, plus the RSS feed, the sitemap and the admin area. If you had a codebase that had the same requirements, you'd find that you have a whole bunch of repeating code. \r\n\r\nThe base query for returning articles, on the primary listing page would look like this:\r\n\r\n```php\r\nArticle::query()\r\n    ->where('post_at', '<=', Carbon::now())\r\n    ->where('active', '=', 1)\r\n    ->where('status', '=', Status::PUBLIC)\r\n    ->paginate(20);\r\n```\r\n\r\nIf we wanted to retrieve only articles that belong to a particular category we’d need to copy the above and add the following `whereHas` clause.\r\n\r\n```php\r\n$query->whereHas('category', function (Builder $query) use($category) {\r\n    $query->where('id', '=', $category->id);\r\n})\r\n```\r\n\r\nWe’d repeat the same process for topics and versions, with the relationship names changed appropriately.\r\n\r\nCreating an operation here would abstract that query out to a single place, allowing you to change the query everywhere at once.\r\n\r\n```php\r\n$articles = (new GetArticle)->perform();\r\n```\r\n\r\nThen when I want to query for category, version or topic articles, I can just add `setCategory($category)`, `setTopic($topic)` or `setVersion($version)` before the `perform()` method. \r\n\r\nIf we were to need something that requires configuring we’d add another setter. That would require us to modify the code calling the operation, but if you’re using a modern IDE, finding usages of a particular class is a trivial process. \r\n\r\nMy operations are typically quite descriptive, and simply act as a layer of abstraction as well as simplification. Due to this, I do actually provide all of the values using setters. You may think that this isn’t at all that different to doing it inline, but each of my setters that adds a single value, could possibly expand out into some more complex code.\r\n\r\nHere’s my usage of the operation:\r\n\r\n```php\r\n$articles = (new GetArticles)\r\n            ->setActiveOnly(true)\r\n            ->setStatuses(Status::PUBLIC)\r\n            ->setPaginate(true)\r\n            ->setLimit(20)\r\n            ->perform();\r\n```\r\n\r\n## Operations vs Repositories\r\nRepositories are a totally valid method of abstraction and can be used with Eloquent, regardless of what others may say, and for the longest time I championed this pattern. \r\n\r\nOver time I found myself having to create many different methods for all the uses cases, while trying to avoid requiring 10s of arguments being passed, which required me to abstract out to yet more methods to avoid repeat code.\r\n\r\nMy first step away from repositories was to introduce the concept of Criteria, which were essentially eloquent scopes but not tied to specific models. Think along the lines of the following:\r\n\r\n```php\r\n$repository->with(new ActiveOnly, new Published)->getArticles(20);\r\n```\r\n\r\nThis was all well and good but I soon hit a point where I needed criteria that was aware of other criteria, which is actually the point where I came up with operations, by taking my criteria and making my criteria the operation.\r\n\r\nThis site actually allows me and other admins to view inactive and non-public articles, adding two possible conditions to the querying of articles. Ignoring the concept of criteria for a minute, let’s take a look at what my particular use-cases could look like when using repositories.\r\n\r\n```php\r\npublic function getArticles(int $limit, bool $active, int $status);\r\npublic function getCategoryArticles(Category $category, int $limit, bool $active, int $status);\r\npublic function getTopicArticles(Topic $topic, $limit, bool $active, int $status);\r\npublic function getVersionArticles(Version $version, $limit, bool $active, int $status);\r\n```\r\n\r\nThere are obviously many ways that you could write these methods, as in my first example I created 8, the 4 you see above plus 4 prefixed with `getPublished`. \r\n\r\nHowever you decide go about this, you will typically find yourself with one of the following:\r\n\r\n- A huge method that handles all cases, with many arguments, and is pretty much the only public method on the repository.\r\n- Several smaller methods that have basically the same code with very slight differences.\r\n- Many smaller methods that mostly abstract out the logic to avoid repeat code (The Taylor approach I call this), but doing nothing but filling the class with arguably unnecessary methods.\r\n\r\nNow let’s take a look at my [`GetArticles`](https://github.com/ollieread/ollieread.com/blob/master/app/Articles/Operations/GetArticles.php) operation. It's 290 lines long, with only 86 of those handling the actual logic. The rest are docblocks, setters or blank-lines. This class has 9 used properties with their own setters.\r\n\r\n- `activeOnly` - A flag denoting whether or not to only query for active articles.\r\n- `statuses` - An int array containing the statuses to query for.\r\n- `limit` - The amount of articles to return.\r\n- `category` - The category that the articles should belong to.\r\n- `topics` - A collection of topic models that the articles should have assigned.\r\n- `versions` - A collection of version models that the articles should have assigned.\r\n- `series` - The series that the articles should belong to (not actually used right now).\r\n- `paginate` - Whether or not to paginate the results, if true the limit is used, otherwise it's a non paginated limited response.\r\n- `liveOnly` - A flag denoting whether the articles should have a `post_at` of less than now.\r\n\r\nThis operation allows me to get the same results as the 4 example repository methods I defined above, as well as many other combinations as are possible. \r\n\r\nIt should also be noted that this operation is arguably my most complex, with `GetTopics` being 134 lines comprising of a 29 line long method (including definition and braces), 6 properties and 6 setters. You can see that operation [here]((https://github.com/ollieread/ollieread.com/blob/master/app/Articles/Operations/GetTopics.php))\r\n\r\n## Operations vs Services\r\nServices are in essence similar to repositories, and would fall foul of the same problems mentioned above. \r\n\r\nYou could however, create a stateful service that has a builder like interface, allowing you to build up your requirements before retrieving the result. In that instance, you’ve basically created an operation. I think the distinction here is primarily that my operations follow a standard pattern, if not an interface, and only perform a single operation, albeit in multiple different ways.\r\n\r\nThere’s not much more to add here, as operations are arguably very specific services.\r\n\r\n## Operations vs Model Methods\r\nThe biggest problem with adding model methods is that Eloquent models already have an insane amount of methods inherited from the parent model and its boatload of traits. Adding more is really going to complicate things, especially if you want decent tab completion in your IDE.\r\n\r\nModel methods would also find itself caught by the same pitfalls as repositories and services. By the time you’d created methods that allowed for all the combinations that my operation allows you’d have as many methods and calls as would be required by just doing it [inline](#operations-vs-inline).\r\n\r\n## Operations Conclusion\r\nThe pros of using my proposed approach are:\r\n\r\n- Provides a level of abstraction for your application and/or business logic.\r\n- Typically requires less code.\r\n- More flexible than creating methods for each use case, when in a model, service or repository.\r\n- Reusable.\r\n- Isn’t limited specifically to database interactions.\r\n- Fluent builder interface is easier to follow and use compared to method arguments.\r\n- Follows the single responsibility principal.\r\n\r\nThe cons of using proposed approach are:\r\n\r\n- Adding extra options in still requires you finding all references and updating accordingly.\r\n- The classes appear far larger than they are in truth.\r\n\r\nOperations are clearly easier to follow and easier to work with, outweighing the cons.\r\n\r\n# Command Query Separation\r\nCommand Query Separation, or [CQS](https://en.wikipedia.org/wiki/Command%E2%80%93query_separation) is a design pattern not entirely dissimilar to that of my operations approach. The biggest difference is that it splits up what I would consider operations into commands and queries, and the specific rules about these are something I didn’t get along with.\r\n\r\n## Commands\r\nCommands in CQS are write operations, that return no result. They are permitted to throw exceptions, and since using exceptions to control the flow of the system is typically frowned upon, that was of little use. \r\n\r\nIf this is the first time you’re hearing of CQS, you’re probably asking “Why on earth would I not want a result?”, which is a question I’m still asking myself. I believe that the general practise here would be to use a query after a command, to query the result.\r\n\r\nBy all means take a read of the CQS pattern and see if you can see something that I missed. I’d be more than happy to hear a sensible argument for this approach.\r\n\r\n## Queries\r\nQueries in CQS are the opposite of commands, performing only read operations and returning the result. Queries can be used by commands, but cannot use commands. I can definitely think of many times where this would be fine and I could live with the few where it wouldn’t.\r\n\r\n## So why not CQS?\r\nMy conclusion with CQS was that it would require the creation of far more classes than my operations approach, definitely more than the obvious 2x, and afford less flexibility without thinning the lines between what is acceptable and what is not.\r\n\r\nMy operation solution combines the two into one, and can in theory return no result like a command, but it’s probably best to always return something.\r\n\r\nPerhaps it’s my understanding of CQS, or lack thereof, but I really don’t see the benefit at all. If you’re a champion of this pattern, or someone with an eye on something that I can’t see, I’d love to hear from you.\r\n\r\n# Conclusion\r\nI tried to approach this topic objectively for this article, and I’ll be the first to admit that I am most probably biased, but I genuinely believe in this approach, not just from the theory, but the practicality of it too.\r\n\r\nThe purpose of this article was to share with you this approach, and try to explain how I came up with this, as well as offer all of the information to you so that you can make your own decision, and/or give me feedback.\r\n\r\nIf you’ve got questions about this, criticism on the approach, or even if you want to inform me that this pattern already exists and is definitely not something I coined, I’d love to hear from you. You can contact me on [twitter](https://twitter.com/ollieread), [discord](https://discordapp.com/invite/k7yUccq) or in the comments below.\r\n\r\nI hope you enjoyed this article.",
    "image": null,
    "active": 1,
    "status": 2,
    "post_at": "2019-10-07 13:00:00",
    "deleted_at": null,
    "created_at": "2019-10-05 14:45:03",
    "updated_at": "2019-10-07 13:51:30"
  }
]